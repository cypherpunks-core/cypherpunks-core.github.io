<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-15T17:19:37+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">密碼龐克 Cypherpunks Taiwan</title><subtitle>密碼學使自由和隱私再次偉大。Cryptography makes freedom and privacy great again.</subtitle><entry><title type="html">多媒體區塊鏈:分散式且防竄改之媒體交易框架</title><link href="http://localhost:4000/news/2020/01/15/%E5%A4%9A%E5%AA%92%E9%AB%94%E5%8D%80%E5%A1%8A%E9%8F%88/" rel="alternate" type="text/html" title="多媒體區塊鏈:分散式且防竄改之媒體交易框架" /><published>2020-01-15T00:00:00+08:00</published><updated>2020-01-15T00:00:00+08:00</updated><id>http://localhost:4000/news/2020/01/15/%E5%A4%9A%E5%AA%92%E9%AB%94%E5%8D%80%E5%A1%8A%E9%8F%88</id><content type="html" xml:base="http://localhost:4000/news/2020/01/15/%E5%A4%9A%E5%AA%92%E9%AB%94%E5%8D%80%E5%A1%8A%E9%8F%88/">&lt;blockquote&gt;
  &lt;p&gt;當前多媒體發佈不會保留可自我檢索的訊息交易或內容修改之歷史記錄，經常對原始媒體進行編輯以獲取創意內容準備或篡改以進行錯誤宣傳通過社交媒體，然而現在沒有可信任之機制可以輕鬆檢視交易記錄或修改歷史。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;

&lt;p&gt;分散式且防篡改的媒體交易框架是基於區塊鏈模型提出的。當前多媒體發佈不會保留可自我檢索的訊息交易或內容修改之歷史記錄。&lt;/p&gt;

&lt;p&gt;例如：珍貴藝術品的數位副本、創意媒體和娛樂內容被發佈於各種目的，包括展覽、畫廊收藏或媒體製作、工作流程。&lt;/p&gt;

&lt;p&gt;經常對原始媒體進行編輯以獲取創意內容準備或篡改以進行錯誤宣傳通過社交媒體，然而現在沒有可信任之機制可以輕鬆檢視交易記錄或修改歷史。&lt;/p&gt;

&lt;p&gt;作者團隊提出了一種新穎的浮水印基於多媒體的區塊鏈框架來解決問題。唯一浮水印訊息包含兩個訊息：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a 包含交易歷史紀錄的加密雜湊&lt;/li&gt;
  &lt;li&gt;b 保留可檢索的原始媒體內容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一旦浮水印提取後，浮水印的第一部分傳遞給分散式帳本以檢索歷史交易記錄和後者，部分用於識別已編輯/已篡改的區域。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本論文概述了需求、挑戰並展示了這個概念的證明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;介紹&quot;&gt;介紹&lt;/h2&gt;

&lt;p&gt;媒體分發也稱為內容分發，是一種多媒體內容的數位分發形式，其中包括音訊、圖片和視訊。&lt;/p&gt;

&lt;p&gt;從歷史上看，媒體發行依賴紙、光碟、DVD 或磁帶的物理交換。但是，在線交付媒體，例如基於 Internet 的雲服務或對等通信，已成為多媒體交付的事實上的標準，可確保高可用性，高性能和成本效益。內容分發網路（CDN）是專用服務器的分佈式網路，該服務器經過優化，可將豐富媒體無縫傳輸到與 Internet 連接的設備。與傳統的 CDN 相比，基於雲的 CDN 更好，因為它具有成本有效的託管服務，而無需擁有基礎架構。&lt;/p&gt;

&lt;p&gt;對於有效的多媒體分發系統，在研究以及行業中都做出了巨大的努力。例如，MPEG 媒體傳輸標準是作為 MPEG 的一部分而開發的，用於通過 Internet 進行多媒體傳輸，其目標是以內容為中心的互聯網，以便通過網路更有效地分發內容。通過索引媒體文件中的多個視訊、音訊、字幕軌道和元數據，提出了一種生成、分發和使用多媒體文件的新方法。但這些解決方案都沒有關注傳送的內容的安全性和完整性，例如，可以很容易地從內容中刪除索引，從而失去了對相關訊息的追蹤。&lt;/p&gt;

&lt;p&gt;周先生等人提出了一個聯合物理和應用層安全框架，該框架利用了物理層的安全能力和訊號處理技術。應用層的身份驗證和浮水印技術。&lt;/p&gt;

&lt;p&gt;該方案旨在通過無線網路安全地傳送多媒體，並且在篡改的情況下不考慮媒體的任何完整性。使用基於安全浮水印以及聯合壓縮和加密的方法，提出了進一步的多媒體內容保護技術。但兩種算法都只關注內容保護，而沒有討論如何將這些技術集成到媒體分發框架中。&lt;/p&gt;

&lt;p&gt;在沒有可以輕鬆搜尋交易或修改歷史記錄的信任機制下，我們提出了一種新穎的基於浮水印的多媒體區塊鏈框架，可以解決此類問題。唯一浮水印訊息包含兩則訊息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a 包含交易歷史紀錄的加密雜湊。&lt;/li&gt;
  &lt;li&gt;b 保留可檢索的原始媒體內容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提取浮水印後，將前一段傳遞到可以搜尋歷史記錄的分散式帳本，而後一部分則用於定位和重建編輯/篡改的區域。通過使用感知壓縮算法(CS)找到最佳解決方案，可以實現原始內容的重建。本文概述了需求，挑戰並證明了這一概念。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-34.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;center&gt;圖1 區塊鏈工作原理概述&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;h3 id=&quot;a區塊鏈&quot;&gt;A.區塊鏈&lt;/h3&gt;

&lt;p&gt;區塊鏈是一種新興技術，本質上是一個開放的分散式帳本（資料庫），記錄所有稱為區塊的交易細節。每個記錄或區塊都帶有時間戳記（TimeStamps），並鏈接到前一個區塊，並具有對數據修改的彈性，因此被認為是兩個實體之間以高效、可驗證和永久的方式進行交易的信任。近年來，許多打算採用該概念以提供安全且可公開驗證的交易機制的大型銀行、金融機構和其他公司注意到，對該技術的投資正在增加。例如，最新的虛擬貨幣 Bitcoin 使用區塊鏈作為其核心技術。&lt;/p&gt;

&lt;p&gt;區塊鏈技術屬於分散式帳本技術的範疇，它允許交易以分散的方式運行，即允許在不使用中心化組織來處理交易的情況下驗證交易。取而代之的是，使用多個節點就交易是否有效達成共識。區塊鏈工作原理的一個示例如圖1所示，其中付款從 A 發送到 B，而其他節點驗證交易。如果交易失敗或無效，則不確認交易。最終，所有節點都將驗證交易並將其添加到其分散式帳本之副本中。從概念上講，它通過鏈接有關交易的訊息區塊並將它們按時間順序儲存在一起，因此稱為區塊鏈。&lt;/p&gt;

&lt;p&gt;除虛擬貨幣外，這項技術還有很大的潛力在傳輸任何虛擬內容的用途。 目前其他潛在的應用場景包括硬體和軟體錢包，合規性和身份以及許多其他財務和交易管理應用程式，例如智能合約。 本質上，區塊鏈與任何事物都相關需要交易驗證或簽名、真實性和信任。 但是，沒有發現重大的努力在基於基本區塊鏈的多媒體應用中 Fujimura 等人介紹的數位版權管理概念等，在區塊鏈交易中添加了正確的訊息。相反，在這項工作中，我們提出了一個完整的框架，該框架保留了媒體交易的所有記錄（例如所有權，許可等），並提供了一種機制來防止媒體的篡改可驗證完整性，從而增強了利益相關者之間的信任。&lt;/p&gt;

&lt;h3 id=&quot;b-多媒體保護&quot;&gt;B. 多媒體保護&lt;/h3&gt;
&lt;p&gt;隨著數位技術在過去十年中顯示出快速增長，內容保護現在在內容管理系統中扮演著重要角色。 在當前系統中，數位浮水印技術提供了強大且可維護的解決方案以增強媒體安全性。 浮水印流行的證據在文獻中清晰可見，其中大多數論文都致力於保護媒體版權，並提出了浮水印算法，這些算法有些難以察覺、對各種有意和無意，例如壓縮的強韌性、過濾或幾何攻擊、脆弱或安全。 自嵌入浮水印方案本質上將主機圖片訊息作為浮水印嵌入圖片本身中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這樣的方案允許篡改檢測和原始圖片像的恢復。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Cox 等人列出了浮水印的各種應用，包括廣播監視、擁有者標籤、所有權證明、認證、交易浮水印、複製控制（Copy Control）和秘密通信。 提出了一種圖片質量評估方法，其中使用離散小波變換（DWT）嵌入浮水印，並使用提取的浮水印的降級來確定質量，而無需參考原始圖片。山田等人開發了一種用於影片播放服務的實時浮水印系統，其中當伺服器收到來自用戶的請求時，對該圖片進行浮水印，這對用戶是唯一的。該系統旨在阻止盜版。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Copy Control 是為了應對近年來日益嚴重的盜拷與檔案分享行為而制定的保護措施。上述盜版行為據稱已造成音樂產業的鉅額損失。實際上，由於 CD 規格在 1980 年代初被制定時尚未有此類問題，因此，與 DVD 相較，CD 標準先天缺乏提供保護或其它數位版權管理能力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Copy Control 是一種試圖在 CD 標準上應用防拷保護的方法。然而，由於它只是基於這種缺乏限制的格式之微小改變，且必須要讓大部份的 CD 播放機能正常播放，其保護效力並不彰。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;出於提出分散式和防篡改媒體交易框架的動機，我們的方法結合了區塊鏈和自嵌入浮水印的概念。 雖然區塊鏈為分散式內容交易框架提供了一種受信任的機制，但基於頻率域小波的自嵌入浮水印算法通過檢測和恢復主機媒體上的任何篡改編輯嘗試來確保內容完整性。&lt;/p&gt;

&lt;h2 id=&quot;提出框架&quot;&gt;提出框架&lt;/h2&gt;

&lt;p&gt;所提出的基於區塊鏈模型的分散式防篡改媒體交易框架包括三個部分：
a）基於感知壓縮（CS）的自嵌入水印
b）區塊鏈分佈式分類帳
c）身份驗證。&lt;/p&gt;

&lt;p&gt;該框架在圖 2 中進行了描述，圖2顯示了內容預處理（用於自嵌入水印）和在區塊鏈中的註冊，圖3中描述了內容認證工作流程。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-35.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;center&gt;圖2 提議的多媒體區塊鏈框架概述：內容處理和交易。&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;1浮水印&quot;&gt;1）浮水印&lt;/h3&gt;

&lt;p&gt;最近，頻率域浮水印技術，特別是基於小波的技術在平衡不可感知性和強韌性方面表現出更好的前景。在這項工作中，我們使用了基於小波的浮水印嵌入方案，其中低頻係數根據浮水印訊息進行了修改。&lt;/p&gt;

&lt;p&gt;a）首先，使用降低採樣率後的原始圖片的基於 CS 的偽隨機投影構造浮水印（如圖2 所示）。然後將其與其他區塊鏈交易訊息結合以形成浮水印字串。字串的長度取決於圖片尺寸以及區塊鏈交易。在我們的實驗設置中，我們使用了 8220（8154 + 66）字長的浮水印字串，圖片大小為 3264×2448。&lt;/p&gt;

&lt;p&gt;b）然後將基於 5/3 提升的一級小波變換應用於原始圖片，並使用低頻子帶（LL）係數嵌入浮水印。生成浮水印字節以形成單個二進製字串，並通過調整兩個相鄰係數來嵌入每個位元，即一個位元數應大於另一個係數以嵌入 1，反之則為 0。該字串在整個子帶中重複嵌入，以確保在篡改的情況下強大的浮水印提取。&lt;/p&gt;

&lt;p&gt;c）最後，在身份驗證期間，將提取的浮水印傳遞到基於 CS 的稀疏重建（如下所述）以檢索原始圖片。接收到的圖片與檢索到的圖片之間的比較有助於識別篡改區域並恢復原始內容。下面給出了基於 CS 的重建的簡要說明。&lt;/p&gt;

&lt;h3 id=&quot;2使用壓縮感應進行信號恢復&quot;&gt;2）使用壓縮感應進行信號恢復&lt;/h3&gt;

&lt;p&gt;CS 理論證明，與 Shannon-Nyquist 定理的最小採樣率相比，可以從一組減少的線性測量結果中重建具有稀疏表示的信號。 稀疏域中給定信號 x∈ℝn 的標準 CS 模型可以描述為：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;y=Φx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中 Φ 是 m×n m≪n＆y∈ℝm 的感知矩陣。稀疏訊號由少量非零係數組成。 因此，密集圖片 I 通常需要具有基本函數 spa 的稀疏變換，例如 DFT、DCT或 DWT，以實現信號的更緊湊的能量分佈。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x=ΨI&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;訊號重建通常是非線性操作，以重建原始訊號的近似值。由於重建的優化約束是不同的，因此某些算法可以重建圖片域值，而不會使等式中的變換變稀疏。 （2）。 基於 CS 的圖片雜湊自嵌入浮水印生成如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;將圖片 I 下採樣至較低的分辨率（N x M），以確保出現實際的 CS 問題。&lt;/li&gt;
  &lt;li&gt;然後，通過 Φ 直接對下採樣圖片 Id 進行隨機採樣，或者通過 Φ 對 I d 的變異係數 X d 進行隨機採樣。&lt;/li&gt;
  &lt;li&gt;將圖片域中的隨機採樣值 y 或頻率域中的變異係數儲存為圖片雜湊水印 w。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;從篡改圖片中提取的浮水印 w’ 可以看作是壓縮樣本 y’，以重建下採樣之原始圖片 I d。 然後，可以應用篡改檢測。所提出的方案對於各種 CS 方法是靈活的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;特別是，測試了兩種恢復策略：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;T 係數的 l1- 範數最小&lt;/li&gt;
  &lt;li&gt;圖片最小化總變化範數&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;範數（英語：norm），是具有「長度」概念的函數。在線性代數、泛函分析及相關的數學領域，是一個函數，其為向量空間內的所有向量賦予非零的正長度或大小。另一方面，半範數（英語：seminorm）可以為非零的向量賦予零長度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;b-多媒體區塊鏈&quot;&gt;B. 多媒體區塊鏈&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-36.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;center&gt;圖3 內容認證和重建的功能流程圖&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文採用標準的區塊鏈基礎架構，並進行了修改以滿足多媒體區塊鏈的要求。如圖2 和圖3 所示，該框架包含兩個部分：
1）內容預處理（用於自嵌入水印）和在區塊鏈中的註冊，以及
2）內容認證。區塊鏈技術可實現去中心化的無信任數字交易。&lt;/p&gt;

&lt;p&gt;交易獲得批准後，該區塊將在區塊鏈的分散式資料庫中進行更新，並由網路中的每個用戶進行記錄。交易可以嵌入智能合約和公眾訊息。該公眾訊息可用於記錄圖片/媒體的交易訊息，例如交易和修改歷史記錄、所有權、區塊鏈交易 ID 等以及可用於重建原始圖片/媒體的 CS 樣本訊息。在分發之前，此公眾訊息將嵌入圖片/媒體本身中。一旦交易被批准，圖片/媒體就準備好分發並儲存在鏈接的內容伺服器（圖2 中的媒體資料庫伺服器）中。資料庫伺服器中交易的圖片/媒體的相應區塊鏈訊息被更新。&lt;/p&gt;

&lt;p&gt;通過提取查詢圖像/媒體的浮水印來實現進一步的分發或認證。查詢圖像/媒體的浮水印包含兩個部分：1. 區塊鏈交易 ID 和 2. 用於重建 CS 的原始圖片樣本。前一部分傳遞到可以檢索交易明細的分散式資料庫，後一部分分別用於重建原始圖片/媒體和定位被篡改的區域。區塊鏈交易 ID 用於檢索查詢圖片/媒體的歷史記錄，包括所有權訊息、發送者和接收者的地址、交易時間、交易的區塊鏈地址、價格等（例如：圖4）。&lt;/p&gt;

&lt;p&gt;CS 樣本用於重建原始圖片的下採樣版本，以識別可能恢復原始圖片區域的任何篡改或編輯區域。如果區塊鏈驗證或篡改檢測身份驗證失敗，則查詢圖片/媒體不真實，並且不準備進行進一步的分發/交易。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-37.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;center&gt;圖4 使用以太坊獲得的特定 ID 的交易歷史記錄。&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-38.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;center&gt;圖5 圖片的資料庫。&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;結果&quot;&gt;結果&lt;/h2&gt;
&lt;p&gt;對於作者的框架，作者使用了現有的區塊鏈基礎架構。區塊鏈網路建立在以太坊的測試網上。我們還使用了一個開源工具箱，用於基於感知壓縮的稀疏樣本生成和重構。 l1 - Magic 工具箱用於解決兩個優化問題，使用WAVELAB 包和 J. Romberg 的 Noiselet 生成小波（Wavelet）。&lt;/p&gt;

&lt;p&gt;為了模擬內容認證中的篡改行為，由 Christlein 等人提供了一個標準資料集。在生成結果時，首先我們通過以太坊測試網和來自主機影像的稀疏隨機樣本生成了交易 ID。將這兩個連接起來以生成由一系列 8 位元組成的浮水印字串。一旦加浮水印，圖片就會被標準資料集可用的現有篡改模板進行保護。最後，我們從受保護之圖片中提取浮水印並重建原始圖片，以檢測編輯。一個成功測試的案例如圖6 所示，其中（a）是原始圖片，（b）是浮水印圖片，（c）是受保護版本，（d）是使用提取的浮水印的重建圖片，而（e）是檢測到的篡改區域。&lt;/p&gt;

&lt;p&gt;提取的交易 ID 也被檢索到以太坊測試網上的相應交易中，以驗證所有權和交易歷史。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;關於 CS 感知壓縮和 l1 - Magic有興趣可以參照&lt;a href=&quot;https://medium.com/r/?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27062896&quot;&gt;這篇&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-39.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;center&gt;圖6 各圖關係 （a）原始圖片（b）浮水印圖片（c）受保護版本（d）使用提取的浮水印的重建圖（e）是檢測到的篡改區域。&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;在本文中，作者提出了一種基於區塊鏈架構的新型分散式防篡改媒體交易框架。 擬議的多媒體區塊鏈框架建立在自嵌入浮水印演算法的基礎上，該算法使用感知壓縮來檢測任何篡改並檢索原始內容。我們已經成功證明了這一概念。&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">當前多媒體發佈不會保留可自我檢索的訊息交易或內容修改之歷史記錄，經常對原始媒體進行編輯以獲取創意內容準備或篡改以進行錯誤宣傳通過社交媒體，然而現在沒有可信任之機制可以輕鬆檢視交易記錄或修改歷史。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/panda-33.png" /></entry><entry><title type="html">使用區塊鏈和感知雜湊達到去中心化之圖像共享和版權保護</title><link href="http://localhost:4000/news/2019/11/24/%E4%BD%BF%E7%94%A8%E5%8D%80%E5%A1%8A%E9%8F%88%E5%92%8C%E6%84%9F%E7%9F%A5%E9%9B%9C%E6%B9%8A%E9%81%94%E5%88%B0%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B9%8B%E5%9C%96%E5%83%8F%E5%85%B1%E4%BA%AB%E5%92%8C%E7%89%88%E6%AC%8A%E4%BF%9D%E8%AD%B7-copy/" rel="alternate" type="text/html" title="使用區塊鏈和感知雜湊達到去中心化之圖像共享和版權保護" /><published>2019-11-24T00:00:00+08:00</published><updated>2019-11-24T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/24/%E4%BD%BF%E7%94%A8%E5%8D%80%E5%A1%8A%E9%8F%88%E5%92%8C%E6%84%9F%E7%9F%A5%E9%9B%9C%E6%B9%8A%E9%81%94%E5%88%B0%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B9%8B%E5%9C%96%E5%83%8F%E5%85%B1%E4%BA%AB%E5%92%8C%E7%89%88%E6%AC%8A%E4%BF%9D%E8%AD%B7%20copy</id><content type="html" xml:base="http://localhost:4000/news/2019/11/24/%E4%BD%BF%E7%94%A8%E5%8D%80%E5%A1%8A%E9%8F%88%E5%92%8C%E6%84%9F%E7%9F%A5%E9%9B%9C%E6%B9%8A%E9%81%94%E5%88%B0%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%B9%8B%E5%9C%96%E5%83%8F%E5%85%B1%E4%BA%AB%E5%92%8C%E7%89%88%E6%AC%8A%E4%BF%9D%E8%AD%B7-copy/">&lt;blockquote&gt;
  &lt;p&gt;本篇文章翻譯自 &lt;a href=&quot;https://ieeexplore.ieee.org/document/8711440&quot;&gt;Decentralised Image Sharing and Copyright Protection using Blockchain and Perceptual Hashes&lt;/a&gt;，媒體區塊鏈的範疇越來越發人深省，究竟該如何透過去中心化的機制來達到版權保護呢？一起來閱讀本篇文章吧！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;

&lt;p&gt;在本文中，我們旨在解決照片上傳到正版圖片網站和圖像共享市場上之圖像來源問題，以確保原創攝影師的作品得到正確認可。&lt;/p&gt;

&lt;p&gt;現在，每週在正版圖片網站上共享數百萬 &lt;strong&gt;Royalty Free&lt;/strong&gt; （RF,免權利金）之圖像。在這樣的網站上分享圖像的攝影師和圖形設計師之間存在著很大的不滿，因為這種行為存在廣泛的弊端，其他人試圖從原作者的作品中獲得榮譽並從中受益。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Royalty Free : 網站對使用者的一種圖片素材授權方式概稱，其意義指使用者一旦購買產品，可以無限次數地使用，每一次使用時，並不需另外就使用的媒體、數量、年限、地域等，付費取得授權。在著作權的相關法律中並無就此詞的規範，但在多媒體出版業界，尤其是數位影像業界中廣泛被使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;當除原作者外的其他人上傳與市場上已經共享的相同圖像，或使用圖像處理方法（例如旋轉、裁剪、灰階轉換等）然後上傳篡改圖像以避免版權侵犯檢測時，就會發生這種情況。為了解決這些問題，我們建議在以太坊測試鏈的基礎上建立一個去中心化的點對點照片共享市場，並展示它是如何公平，值得信賴和實用的。&lt;/p&gt;

&lt;p&gt;我們的分散式應用程序利用以太坊的感知雜湊和強大的智能合約來自動檢測和拒絕在感知雜湊上與市場上已有的圖像或相似的篡改圖像。由於區塊鏈的固有特性，我們的市場沒有中央機構對其進行控制，沒有任何第三方干擾、沒有單點故障、零審查並保留了在線用戶隱私。&lt;/p&gt;

&lt;p&gt;據我們所知，這是第一項提供實用解決方案的工作，可在分散的圖像共享平台上自動檢測和拒絕在感知上相似的圖像，從而保護正版圖像作者的版權。&lt;/p&gt;

&lt;h2 id=&quot;第一章節---介紹&quot;&gt;第一章節 - 介紹&lt;/h2&gt;

&lt;p&gt;在當前的互聯網時代，許多攝影師現在通常是透過正版照片公司通過線上出售圖像來賺取收入。這些網站上的免版稅和微圖庫之商業模式已導致攝影師之間的激烈競爭，每個人都在努力上傳更多圖像並獲得更多作品下載。&lt;/p&gt;

&lt;p&gt;最近這種行為導致了廣泛的圖像來源欺詐，其中一些非作者違反了版權法並在心理和經濟上影響了合法圖像所有者，從而獲得了其他供圖者者圖像的信譽。他們通過從正版照片網站訪問原始作者的圖像並按原樣或在修改了正版照片網站上的某些圖像特徵後上傳由此獲得的圖像來實現此目的。儘管一些圖片網站確實通過使用密碼雜湊來檢查要上傳的新圖像是否已經存在於市場上，但它們無法識別原始圖像的可操縱版本。發生這種情況是因為密碼雜湊易於產生雪崩效應，這種現像是輸入值的微小變化導致輸出值的急劇變化。我們通過創建一個基於以太坊的圖像共享解決方案並選擇感知雜湊來解決這些問題[6]。感知雜湊避免雪崩效應，並且不易受到圖像感知變化的影響，例如旋轉，裁剪，調整大小，轉換為灰階、胡椒鹽攻擊，曝光或飽和度變化等。本文展示如何使用區塊鏈網路結合使用感知雜湊和適當的智能合約邏輯提供比當前系統更好的版權侵權檢測機制，以及區塊鏈的許多好處，例如永久性的交易記錄、透明度、信任、不變性、高可用性、信息安全和節省成本。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;microstock : 在圖庫網上，有人有需求購買圖像/影片/音樂素材，自然就會有「供圖者 Contributor」。每個人都可以在這些圖庫網站上註冊申請成為供圖者。但因應每家的規則要求，在正式成為可上架素材產品賺取佣金的供圖者前，有的網站會有一些小考試（像是要先上傳幾張圖供站方審合是否符合他們的要求水準）。不過這個倒不用擔心，現在這些測試門檻都很低，基本上只要符合各類素材的一些格式設定大多會通過。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;cryptographic hash : 可以將任意大小的數據（通常稱為「消息」）映射到固定大小的位字符串（「雜湊值」、「雜湊」或「消息摘要」），並且是單向的函數，即實際上不可行的函數。[1] 理想情況下，查找產生給定的消息的唯一方法是嘗試暴力搜尋，以查看它們是否產生匹配項，或使用匹配雜湊表的Rainbow 表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;a-動機&quot;&gt;A. 動機&lt;/h3&gt;

&lt;p&gt;提出去中心化圖像共享市場的基本動機是糾正圖像來源並為原始圖像作者提供應有的信譽，這是在正版圖片網站上共享圖像的攝影師主要關注點。我們旨在建立強大且快速的版權侵犯檢測機制。當與基於區塊鏈的架構優勢結合時，可以將權力交還給圖像貢獻者。正版照片網站上的佣金率（可能高達 55％）也是攝影界普遍關注的問題。我們的目標是完全擺脫這些繁重的佣金，並創建一種架構，使用戶僅需支付與區塊鏈網路處理交易相關的交易費用。&lt;/p&gt;

&lt;h3 id=&quot;b-新穎性&quot;&gt;B. 新穎性&lt;/h3&gt;

&lt;p&gt;此專案新穎的貢獻包括使用可以編程的以太坊區塊鏈[1]，[4]創建一個去中心化的圖像共享應用，並以新穎的方式使用感知雜湊、以太坊上強大的智能合約[12]，[15]進行版權之侵犯檢測。網路上的照片通過 IPFS 以分散方式保存。我們最後也提供計算之結果，顯示我們方法的有效性和限制。&lt;/p&gt;

&lt;h2 id=&quot;第二章節---系統環境及建置&quot;&gt;第二章節 - 系統環境及建置&lt;/h2&gt;

&lt;p&gt;我們使用以下工具和技術來建置我們的系統。關於它們的詳細信息可以在各自的網站和相應的 Github 中找到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Metamask : Metamask 是用於瀏覽器的插件，可進行以太坊交易。它允許運行以太坊 Dapps（去中心化應用程序），而無需運行完整的以太坊節點，管理身份和簽署區塊鏈交易。&lt;/li&gt;
  &lt;li&gt;Ganache：Ganache 是一個以太坊區塊鏈模擬器。Ganache 是一個以太坊測試節點，可以在本地測試所有 Componet 組件。它還允許用戶部署合約，開發應用程序並運行測試。&lt;/li&gt;
  &lt;li&gt;Geth : Geth（以太坊）是一個終端機（Command Line）界面，可讓用戶運行和操作以太坊全節點。它在 Go（Golang）中實現，並允許挖掘區塊以生成以太幣、創建智能合約，發送交易以在以太坊地址之間轉移資金，檢查區塊歷史以及許多其他功能。&lt;/li&gt;
  &lt;li&gt;Turffle：Truffle 用於編譯，測試，構建智能合約，並提供開發框架以提高開發過程的速度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;圖1中詳細顯示了系統架構。下面描述了該圖中顯示的各種模組：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;買方模組：它提供了搜索工具，可在分散式應用程序上顯示的所有圖像中找到購買者正在尋找的圖像類別。&lt;/li&gt;
  &lt;li&gt;賣方模組：它提供了在區塊鏈上上傳圖像的簡單方法。賣方上傳圖像，以及圖像名稱和描述以幫助搜索過程。&lt;/li&gt;
  &lt;li&gt;錢包模組：該客戶端加密模組允許創建新的以太坊地址或導入現有地址，請參閱錢包餘額和交易。用戶也可以使用 Metamask 來管理帳戶和錢包。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;從圖1可以看出，以太坊與 Web 客戶端連接並允許訪問以太坊系統。Web 客戶端包括買方，賣方和錢包模組。交易模組用於指定圖像售價，圖像上傳模組用於上傳新圖像。本地端資料庫儲存數據，並且在以太坊網路批准交易後，經過適當的加密後將數據和圖像將傳輸到 IPFS。我們使用公開金鑰加密技術進行加密。由於 IPFS 是內容可尋址的，因此此加密步驟對於訊息保護至關重要。以太坊由 Geth、奇偶校驗和 JSON-RPC（遠程過程調用）協議組成。以太坊提供對以太坊主網路的訪問，該網路由所有用戶節點、礦工、智能合約和交易區塊組成。所有模組之間的數據流如圖所示。下一部分將說明用於訊息儲存的 IPFS 和以太坊網路。
&lt;br /&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-29.png&quot; style=&quot;width:100%&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;圖1 系統架構&lt;/strong&gt; &lt;/center&gt;

&lt;h2 id=&quot;第三章節---方法&quot;&gt;第三章節 - 方法&lt;/h2&gt;

&lt;p&gt;我們提出了兩種不同的體系結構，它們儲存數據的方式不同。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;以太坊儲存：在這種架構中，圖像和雜湊值儲存在以太坊鏈本身上。圖像和感知雜湊被放置在區塊鏈交易中。這種方法的問題在於，隨著越來越多的圖像上傳，由於所有內容都儲存在測試鏈中，因此區塊鏈的儲存大小將迅速增加。每當新節點到達時，他們都必須下載包含所有圖像的整個鏈。該解決方案絕對不可擴展，特別是因為圖像大小可能會達到數兆字元。&lt;/li&gt;
  &lt;li&gt;IPFS 儲存：在這種體系結構中，圖像和雜湊值儲存在 IPFS 中，這是一種分散的超媒體分佈協議。 IPFS [5]的內容是可透過地址搜尋的，並使用加密雜湊為文件內的區塊提供唯一的指紋，消除了網路上的冗餘，並將這些唯一的雜湊用於訊息檢索。通過使用 IPFS 協議儲存圖像和可感知的雜湊，我們在以太坊測試鏈的大小上節省了很多。可以使用任何標準加密方案對儲存在IPFS 上的數據進行加密並進行檢索。加密私鑰將僅通過智能合約與適當的買方共享。這種方法是可擴展的，是我們實施中使用的一種方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;a-侵犯版權和電腦視覺&quot;&gt;A. 侵犯版權和電腦視覺&lt;/h3&gt;

&lt;p&gt;感知雜湊是多媒體指紋算法，它考慮了多媒體的各種功能。對於線上多媒體市場來說，&lt;strong&gt;確保每個作品只能上傳一次非常重要&lt;/strong&gt;。通過將新的圖像雜湊值與區塊鏈上所有圖像的雜湊值進行比較並檢查，諸如 MD5 和 SHA 之類的密碼雜湊函數可以有效地完成此任務。但是我們走得更遠，還嘗試找出似乎是區塊鏈上已經存在的原始作品的修改作品，並且在感覺上與這些原始作品相似。例如，如果有人嘗試上傳稍微旋轉的圖片（例如逆時針說12°），則由於雪崩效應，諸如SHA之類的雜湊將具有完全不同的最終雜湊值。相反，如果我們使用感知雜湊，則最終雜湊中的某些位元或沒有位元更改。我們可以使用感知雜湊的此屬性來找到圖像之間的相似性。實現此目的的方式是通過計算原始圖像和測試圖像之間的差異。為了量化差異，找到兩個圖像的感知雜湊值並計算由此獲得的雜湊值之間的漢明距離。標準化 0 到 1 之間的漢明距離。這是原始圖像與測試圖像之間差異的量度，稱為 NHD。如果這種差異在某個閾值內，則測試圖像將被拒絕。但有時，兩個不同的原始圖像也可能具有近似相似的感知雜湊，從而導致較小的相異值。因此，此處的關鍵任務是找到閾值，以便我們可以盡可能正確地識別兩個不同的圖像和兩個感知相似的圖像。我們在結果部分描述獲取閾值的方法。&lt;/p&gt;

&lt;p&gt;感知雜湊算法很多，但是我們使用了四種最受歡迎的算法，分別是phash（DCT 雜湊），差分雜湊，平均雜湊和小波雜湊。這些算法包含在python 的 ImageHash 庫中，其中提供了有關這些算法的詳細文檔。因此，如果有人上傳了市場上存在的原始圖像的篡改版本，智能合約將計算其感知雜湊，計算此雜湊的漢明距離以及儲存在分散的 PERC HASH 資料庫中的雜湊，和閾值進行比較後將拒絕此類圖像。因此，不僅欺詐者無法上傳此類圖像，而且他們還將支付與在以太坊網路上處理該交易相關的交易費用，這可視為罰款。因此，這種經濟處罰將阻止欺詐行為。&lt;/p&gt;

&lt;h3 id=&quot;b-智能合約和訊息流&quot;&gt;B. 智能合約和訊息流&lt;/h3&gt;

&lt;p&gt;訊息流如圖1所示的系統架構圖所示。智能合約是以太坊生態系統的核心。以太坊上的智能合約是區塊鏈中的一小段程式碼。智能合約的概念最早由 Szabo 提出[3]。它們用於管理用戶之間的協議。他們可以持有以太（ETH），將其提供給適當的實體，持有訊息並為其他智能合約提供效用。智能合約用於執行某些計算，儲存一些變量並交易數位商品，同時遵守合約中提到的某些特定條件。因此，人們可以在以太坊網路上以這些合約中指定的自定義條件（function）交易虛擬資產。由於這些特性，它們適用於包括圖像許可和版權保護邏輯[12]。我們使用 solidity [10]撰寫智能合約，這是迄今為止撰寫智能合約最流行的語言。我們遵循創建此類合約的最佳實踐[16]，並使用諸如小波雜湊（WHASH）之類的輕量級算法來提供版權保護，從而需要較少的手續費（Gas Fees）[13]。我們所有的交易都透過智能合約進行。我們使用智能合約來計算感知雜湊，將加密和解密金鑰分配給適當的實體，與 IPFS 連接，檢查是否侵犯版權及是否接受或拒絕圖像。透過計算標準化漢明距離（NHD）量化市場上存在的圖像與新上傳的圖像之間的圖像差異後，智能合約將拒絕 NHD 低於特定閾值的圖像，如表2和圖2所示。這裡 WHASH 能夠識別除 90° 旋轉版本外的經典 barbara 圖像的所有變換。為了確定圖像的接受或拒絕，將 WHASH 的閾值設為在結果部分中計算的 0.379。這表明了感知雜湊的有效性和可靠性水平。如果對圖片的修改不太極端，並且原始圖片與其被篡改版本之間仍具有良好的結構相似性，則感知雜湊能夠檢測到篡改。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-30.png&quot; style=&quot;width:100%&quot; /&gt;
&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖2 從左到右的圖像：經典圖像barbara，barbara 旋轉 5 度，barbara 旋轉 25 度，barbara 旋轉 90 度，barbara 亮度 -50，barbara sat +50。&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-31.png&quot; style=&quot;width:100%&quot; /&gt;
&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;表2 根據 Bsds-500 資料集計算的各種感知雜湊的有效性比較&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;第四章節---結果&quot;&gt;第四章節 - 結果&lt;/h2&gt;

&lt;p&gt;我們在原始圖像和圖像的變換的資料集上測試模型，以評估感知雜湊在檢測版權侵權中的有效性。我們使用 Berkeley 分割資料集（BSDS）[7]，它是500 個原始圖像的資料集。現實生活中有效的雜湊算法將是一種可以區分兩個真實圖像和同一圖像轉換的算法。&lt;/p&gt;

&lt;p&gt;我們對 BSDS-500 資料集中的每個圖像執行以下轉換：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;旋轉(度數)：5 度 , 10 度 , 15 度 , 20 度, 25度（順時針）&lt;/li&gt;
  &lt;li&gt;Gamma 校正：0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5&lt;/li&gt;
  &lt;li&gt;胡椒和鹽的雜訊：0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00&lt;/li&gt;
  &lt;li&gt;裁切（固定縱橫比模式）：5%, 10%, 15%, 20%, 25%&lt;/li&gt;
  &lt;li&gt;調整大小（尺寸縮小 - 固定寬高比模式）：5％, 10％, 15％, 20％, 25％&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;經過這些轉換，我們最終得到了 21500 張圖像（500 張原始圖像和每個原始圖像 42 張轉換）。為了評估雜湊算法的有效性，我們創建了兩種情況：&lt;/p&gt;

&lt;p&gt;正面（陽性）的情況：在這種情況下抓到的圖像是市場上原始圖像的操縱版本。我們期望雜湊算法能夠檢測到此類欺詐圖像，而智能合約應立即將其拒絕。&lt;/p&gt;

&lt;p&gt;負面（陰性）的情況：這種情況下的圖像是資料集中的兩個不同的原始圖像。網路應允許新上傳的獨特圖像添加到要出售的市場上。&lt;/p&gt;

&lt;p&gt;漢明碼距離是兩個雜湊間不同位元數量。因此，漢明碼距離帶有隱含的不相似感。我們計算新圖像與區塊鏈上傳的所有先前圖像之間的漢明碼距離，將距離值標準化並將其與閾值進行比較，以決定是否接受或拒絕新圖像。這樣，將對照市場上正在交易的所有圖像檢查新圖像。我們計算標準化漢明碼距離（NHD）如下：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/img/panda-32.png&quot; style=&quot;width:100%&quot; /&gt;
&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖3 特定知覺雜湊對正確分類正面和負面案例的有效性。X軸表示NHD，Y軸表示全部圖像的一部分。&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NHD 計算方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;NHD = HammingDistance / HashBitsCount&lt;/script&gt;

&lt;p&gt;我們考慮的所有四種雜湊算法都返回 64 位元雜湊。 以下指標用於評估感知雜湊函數的質量：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.twblogs.net/a/5b7d17972b71770a43ddde64&quot;&gt;Earth Mover’s Distance（EMD)&lt;/a&gt;是對區域內兩個概率分佈之間的距離的度量。 EMD 基於將一種分配轉換為另一種分配所必須支付的最低成本[9]。需要更大的 EMD 值。&lt;/p&gt;

&lt;p&gt;Intersection-Over-Union：Intersection-Over-Union（IoU）是一種評估指標，用於測量特定數據集上對象檢測器的準確性。希望 IoU 值較小。&lt;/p&gt;

&lt;p&gt;閾值：閾值是規格值，如果未超過標準化漢明距離（NHD），則圖像將被拒絕。因此，如果 NHD 大於閾值，則相異性會超過所需值，並且圖像會在市場上被接受。要選擇最佳閾值，請專注於圖3。當負向案例數值首次與正向案例交叉時，將相應的縮放距離值將作為閾值。&lt;/p&gt;

&lt;p&gt;圖3分別顯示了 phash、dhash、平均雜湊和小波雜湊的圖形比較。在此，X 軸表示在 0 到 1 之間縮放的漢明碼距離，而 Y 軸表示圖像出現正向或負向情況的概率。我們希望使用感知雜湊算法，該算法在正向分佈和負向分佈之間提供最小的重疊。可以使用 IOU 度量標準來計算。我們更希望在正負向分佈之間具有最高 EMD 的算法。&lt;/p&gt;

&lt;p&gt;從表2中可以看出，所有四種雜湊算法在度量標準上都給出了可比較的值。平均雜湊和 Dhash 具有較高的 EMD 值，平均雜湊具有最小的 IoU 值。平均雜湊的閾值為0.304。這意味著，如果新圖像的平均雜湊值與市場上現有圖像的平均雜湊值相似的位元率超過 30.4％，則新圖像將被網路批准並添加到市場中。&lt;/p&gt;

&lt;p&gt;雜湊平均時間的比較如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PHASH: 33.97 ms&lt;/li&gt;
  &lt;li&gt;DHASH: 29.93 ms&lt;/li&gt;
  &lt;li&gt;平均雜湊 AVG HASH: 29.81 ms&lt;/li&gt;
  &lt;li&gt;WHASH: 60.99 ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;驗證新圖像所需的時間與在市場上傳的圖像數量成正比。換句話說，新圖像驗證的時間複雜度是呈線性的。&lt;/p&gt;

&lt;h2 id=&quot;第五章節---結論&quot;&gt;第五章節 - 結論&lt;/h2&gt;

&lt;p&gt;我們得出的結論是，針對線上正版圖片市場且基於區塊鏈的解決方案比傳統市場具有許多優勢，例如高安全性、永久性交易記錄、自定義許可證、圖像的自定義銷售價格，更高的貢獻者收入以及允許使用 IPFS 的幫助。由於缺乏中央權威，因此市場不受審查和干擾。經過全面評估，我們得出結論，感知雜湊是一種有效且高效的版權侵權檢測工具。區塊鏈交易僅包含用於檢索圖像的 IPFS 雜湊。通過預先選擇加密方案對智能合約中的內容進行加密，然後將數據傳輸到 IPFS，可以增強訊息安全性。智能合約僅將解密金鑰發布給適當的買方。此外，我們的實現是具擴展性。因此，本文舉例說明了一種經過驗證的技術的新穎用例，可幫助應對照片世界中根深蒂固的惡意行為。&lt;/p&gt;

&lt;h2 id=&quot;第六章節---限制和未來展望&quot;&gt;第六章節 - 限制和未來展望&lt;/h2&gt;

&lt;p&gt;我們的系統可以在合理範圍內檢測到在外觀上與原始圖像相似的假圖像。儘管感知雜湊在檢測許多轉換中非常有效，但是在某些情況下，如表1中 90 度旋轉的 barbara 圖像所示，雜湊算法無法識別欺詐圖像，總結來說，感知雜湊在準確性和時間複雜度上提供一個很好的運作。&lt;/p&gt;

&lt;p&gt;我們打算將來進行以下任務：
為了解決諸如圖2和表1所述的漏洞，我們需要研究和採用比感知雜湊（如果有）更健壯和高效的電腦視覺技術。 
將此分散式應用程序（DApp）轉變為成熟的分佈式自治組織（DAO），該組織還可以提供索賠協助，對索賠進行分散式投票，獎勵管理以及針對侵犯版權的報酬。&lt;/p&gt;

&lt;h2 id=&quot;參考文獻&quot;&gt;參考文獻&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;G. Wood, “Ethereum: A secure decentralised generalised transaction ledger”, Ethereum Project Yellow Paper, 2014.&lt;/li&gt;
  &lt;li&gt;S. Nakamoto, Bitcoin: A peer-to-peer electronic cash system, White paper, 2008.&lt;/li&gt;
  &lt;li&gt;Nick Szabo, The idea of smart contracts, 1997.&lt;/li&gt;
  &lt;li&gt;V Buterin, A next-generation smart contract and decentralized application platform, White Paper, 2014.&lt;/li&gt;
  &lt;li&gt;Juan Benet, IPFS -Content Addressed Versioned P2P File System (DRAFT 3), 2017, [online] Available: https://github.com/ipfs/papers.&lt;/li&gt;
  &lt;li&gt;C. Zaunerm, Implementation and benchmarking of perceptual image hash functions, 2010.&lt;/li&gt;
  &lt;li&gt;P. Arbelaez, M. Maire, C. Fowlkes, J. Malik, “Contour Detection and Hierarchical Image Segmentation”, IEEE TPAMI, vol. 33, no. 5, pp. 898-916, May 2011.&lt;/li&gt;
  &lt;li&gt;V. Monga, B. L. Evans, “Perceptual image hashing via feature points: performance evaluation and tradeoffs”, Image Processing IEEE Transactions on, vol. 15, no. 11, pp. 34523465, 2006.&lt;/li&gt;
  &lt;li&gt;Y. R Ubner, C. Tomasi, L. J. Andguibas, “The earth movers distance as a metric for image retrieval”, Int. J. Comput. Vision 40 99121, 2000.&lt;/li&gt;
  &lt;li&gt;Solidity, 2015.&lt;/li&gt;
  &lt;li&gt;V. Buterin, On public and private blockchains, 2015, [online] Available: https://blog.ethereum.org/2015/08/07/on-public-and-privateblockchains.&lt;/li&gt;
  &lt;li&gt;V. Morabito, “Smart contracts and licensing”, Business Innovation Through Blockchain, pp. 101-124, 2017.&lt;/li&gt;
  &lt;li&gt;T. Chen, X. Li, X. Luo, X. Zhang, “Under-optimized smart contracts devour your money”, 2017 IEEE 24th International Conference on Software Analysis Evolution and Reengineering (SANER), pp. 442-446, 2017.&lt;/li&gt;
  &lt;li&gt;A. Bogner, M. Chanson, A. Meeuw, “A decentralised sharing app running a smart contract on the ethereum blockchain”, Proceedings of the 6th International Conference on the Internet of Things, pp. 177-178, 2016.&lt;/li&gt;
  &lt;li&gt;L. Luu, D.-H. Chu, H. Olickel, P. Saxena, A. Hobor, “Making smart contracts smarter”, Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security CCS ’16, pp. 254-269, 2016.&lt;/li&gt;
  &lt;li&gt;K. Delmolino, M. Arnett, A. Kosba, A. Miller, E. Shi, “Step by step towards creating a safe smart contract: Lessons and insights from a cryptocurrency lab”, International Conference on Financial Cryptography and Data Security, pp. 79-94, 2016.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">本篇文章翻譯自 Decentralised Image Sharing and Copyright Protection using Blockchain and Perceptual Hashes，媒體區塊鏈的範疇越來越發人深省，究竟該如何透過去中心化的機制來達到版權保護呢？一起來閱讀本篇文章吧！</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/panda-28.png" /></entry><entry><title type="html">Bitcoin中Base58Check編碼</title><link href="http://localhost:4000/news/2019/11/19/Bitcoin%E4%B8%ADBase58Check%E7%B7%A8%E7%A2%BC/" rel="alternate" type="text/html" title="Bitcoin中Base58Check編碼" /><published>2019-11-19T00:00:00+08:00</published><updated>2019-11-19T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/19/Bitcoin%E4%B8%ADBase58Check%E7%B7%A8%E7%A2%BC</id><content type="html" xml:base="http://localhost:4000/news/2019/11/19/Bitcoin%E4%B8%ADBase58Check%E7%B7%A8%E7%A2%BC/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/Bitcoin中Base58Check.html&quot;&gt;[原文]&lt;/a&gt;Base58二進位制到文字編碼被稱為 Base58Check，用於編碼比特幣地址。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;p&gt;更一般地說，Base58Check 編碼用於將比特幣中的位元組陣列編碼為人類可分類的字元串。&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;最初的比特幣客戶端原始碼解釋了 base58 編碼背後的原因：&lt;/p&gt;

&lt;p&gt;base58.h：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 為什麼 base-58 而不是標準的 base-64 編碼？
// - 不希望 0OIl 字元在某些字型和字型中看起來相同
//可以用來建立視覺上相同的賬號。
// - 具有非字母數字字元的字元串並不像帳號那麼容易被接受。
// - 如果沒有標點符號，電子郵件通常不會換行。
// - 如果全部是字母數字，Doubleclicking 會將整個數字選為一個單詞。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;base58check的功能&quot;&gt;Base58Check的功能&lt;/h2&gt;

&lt;p&gt;Base58Check 具有以下功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一個任意大小的 payload（ &lt;strong&gt;這個 payload 其實就是公鑰的 HASH160 的雙次 hash 值&lt;/strong&gt; ）。&lt;/li&gt;
  &lt;li&gt;由容易區分的大寫和小寫字母組成的一組 58 個字母數字符號（ &lt;code class=&quot;highlighter-rouge&quot;&gt;0OIl&lt;/code&gt; 不使用）( &lt;strong&gt;主要的原因還是因為可能會產生歧義&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;一個位元組的 version/application 資訊。對於這個位元組比特幣地址使用 0x00（未來的可能使用 0x05 ）。&lt;/li&gt;
  &lt;li&gt;四個位元組（32 位）基於 SHA256 的錯誤校驗碼。此校驗碼可用於自動檢測並可能更正印刷錯誤。&lt;/li&gt;
  &lt;li&gt;保留資料中前導零的額外步驟。（這裡應該更深入地進行分析才是，但是現在真不太明白這裡面的意思。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;建立一個-base58check-字元串&quot;&gt;建立一個 Base58Check 字元串&lt;/h2&gt;

&lt;p&gt;Base58Check 字元串是從 version/application 位元組和 payload 建立的，如下所示。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;獲取 version 位元組和 payload 位元組，並將它們連線在一起（按位元組）。&lt;/li&gt;
  &lt;li&gt;取 SHA256 的前四個位元組（ SHA256 （步驟 1 的結果））（ &lt;strong&gt;也應該是前面提到的那四個位元組的事情&lt;/strong&gt; ）&lt;/li&gt;
  &lt;li&gt;將步驟 1 的結果和步驟 2 的結果連在一起（按位元組順序）。&lt;/li&gt;
  &lt;li&gt;處理步驟3的結果 - 一系列位元組 -  &lt;strong&gt;作為單個大端序號&lt;/strong&gt; ，使用正常的數學步驟（ bignumber division ）和下面描述的 base-58 字母表轉換為 base-58 。結果應該被標準化為沒有任何前導的 base-58 零（字元 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; ）。( &lt;strong&gt;這裡注意前導 0 對應的 Base58Check 是1&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;在 base58 中值為零的前導字元&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;被保留用於表示整個前導零位元組，就像它處於前導位置時一樣，沒有值作為 base-58 符號。必要時可以有一個或多個前導 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 來表示一個或多個前導零位元組。計算第3步結果的前導零位元組數（對於舊的比特幣地址，至少有一個用於版本/應用程式位元組;對於新地址，將永遠不會有）。每個前導零位元組在最終結果中應由其自己的字元 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 表示。&lt;/li&gt;
  &lt;li&gt;將步驟5中的1與步驟4 的結果連線起來。這是 Base58Check 的結果。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在描述比特幣地址&lt;a href=&quot;https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address&quot;&gt;技術背景&lt;/a&gt;的頁面上提供了一個更詳細的例子。&lt;/p&gt;

&lt;h2 id=&quot;編碼比特幣地址&quot;&gt;編碼比特幣地址&lt;/h2&gt;

&lt;p&gt;比特幣地址是使用以下任一項的雜湊的 Base58Check 編碼實現的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pay-to-script-hash（p2sh）：有效載荷是：其中 redeemScript 是錢包知道如何消費的指令碼; 版本（這些地址以數字&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;開頭） RIPEMD160(SHA256(redeemScript))0x05&lt;/li&gt;
  &lt;li&gt;支付到PUBKEY雜湊（ p2pkh ）：有效載荷是其中 ECDSA_publicKey 是錢包知道的私有金鑰的公共金鑰; 版本（這些地址以數字&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;開頭）RIPEMD160(SHA256(ECDSA_publicKey))0x00&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在這兩種情況下得到的雜湊總是恰好為 20 個位元組。這些是大端（最重要的位元組在前）。（注意那些限制前導 0x00 位元組的數字編碼實現，或者預先增加額外的 0x00 位元組來表示符號 - 你的程式碼必須正確處理這些情況，否則你可能會生成可以傳送到但看不到的有效地址 -導致硬幣的永久損失。）&lt;/p&gt;

&lt;h2 id=&quot;編碼一個私鑰&quot;&gt;編碼一個私鑰&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Base58Check 編碼也用於編碼錢包匯入格式中的&lt;a href=&quot;https://en.bitcoin.it/wiki/Private_key&quot;&gt;ECDSA 私鑰&lt;/a&gt;&lt;/strong&gt; 。除了 0x80 用於 version/application 位元組，並且有效載荷是 32 位元組而不是 20 （比特幣中的私鑰是單個 32 位元組無符號的大端整數）之外，它與比特幣地址完全相同。對於與未壓縮的公鑰相關的私鑰，這種編碼總是會產生一個以 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt; 開頭的 51 個字元的字元串，或者更具體地說&lt;code class=&quot;highlighter-rouge&quot;&gt;5H&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;5J&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;5K&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;base58-符號圖表&quot;&gt;Base58 符號圖表&lt;/h2&gt;

&lt;p&gt;比特幣中使用的 Base58 符號圖特定於比特幣項目，並不打算與比特幣之外使用的任何其他 Base58 實現（排除的字元為：&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;）相同。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;字元&lt;/th&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;字元&lt;/th&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;字元&lt;/th&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;字元&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;C&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;G&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;J&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;L&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;Q&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;U&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;c&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;36&lt;/td&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;e&lt;/td&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;f&lt;/td&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;g&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;40&lt;/td&gt;
      &lt;td&gt;h&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;i&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;43&lt;/td&gt;
      &lt;td&gt;k&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;n&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;o&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;p&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;q&lt;/td&gt;
      &lt;td&gt;49&lt;/td&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;t&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;u&lt;/td&gt;
      &lt;td&gt;53&lt;/td&gt;
      &lt;td&gt;v&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;x&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;56&lt;/td&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;z&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;編碼 address_byte_string 的演算法（由1-byte_version + hash_or_other_data + 4-byte_check_code組成）是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;code_string = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;
x = convert_bytes_to_big_integer(hash_result)

output_string = &quot;&quot;

while(x &amp;gt; 0)
{
(x, remainder) = divide(x, 58)
output_string.append(code_string[remainder])
}

repeat(number_of_leading_zero_bytes_in_hash)
{
output_string.append(code_string[0]);
}

output_string.reverse();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;版本位元組&quot;&gt;版本位元組&lt;/h2&gt;

&lt;p&gt;以下是一些常見的版本位元組：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;小數版本&lt;/th&gt;
      &lt;th&gt;領導的象徵&lt;/th&gt;
      &lt;th&gt;使用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Bitcoin pubkey hash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Bitcoin script hash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Bitcoin (compact) public key (proposed)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;M or N&lt;/td&gt;
      &lt;td&gt;Namecoin pubkey hash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;128&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Private key&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;111&lt;/td&gt;
      &lt;td&gt;m or n&lt;/td&gt;
      &lt;td&gt;Bitcoin testnet pubkey hash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;196&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Bitcoin testnet script hash&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://en.bitcoin.it/wiki/List_of_address_prefixes&quot;&gt;地址字首列表&lt;/a&gt;是一個完整的列表。&lt;/p&gt;

&lt;h2 id=&quot;也可以看看&quot;&gt;也可以看看&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://lenschulwitz.com/base58&quot;&gt;線上 Base58 解碼器，編碼器和驗證器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原始碼&quot;&gt;原始碼&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp&quot;&gt;“Satoshi”C ++ codebase&lt;/a&gt;（解碼和編碼，不需要外部庫）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/luke-jr/libbase58&quot;&gt;libbase58 C 程式碼&lt;/a&gt;（解碼和編碼，不需要外部庫）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lenschulwitz.com/b58/base58perl.txt&quot;&gt;Base58 在 Perl 中解碼，編碼和驗證&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;參考和引用&quot;&gt;參考和引用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.bitcoin.it/wiki/Base58Check_encoding&quot;&gt;Base58Check encoding&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;總結&quot;&gt;總結&lt;/h2&gt;

&lt;p&gt;關於比特幣地址知識，在精通比特幣中有詳細地介紹，這裡我們不做更多的介紹，這篇文章是我翻譯的結果。&lt;/p&gt;

&lt;p&gt;在之前我們分析過橢圓曲線的知識，對於確定性錢包的知識我們也做了相關地介紹，還有就是分層確定性錢包的知識。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;另外 Base58Check 還有一個極大的好處就是可以校驗地址是不是正確的，因為 Base58 生成的時候是加入了校驗碼&lt;/strong&gt; 。我覺得比特幣團隊做的真的是很棒不是嗎？詳情可以參考：&lt;a href=&quot;http://8btc.com/thread-31201-1-1.html&quot;&gt;為什麼以太坊地址中沒有校驗值？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;對於比特幣地址也要特別注意一下，地址類型也就是 version/appication 欄位其實是自己加入的，和 ecdsa 本身並沒有任何關係。校驗碼也是自己加上去的而已。我們可以看一下下面的圖片.&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600&quot; src=&quot;/img/139.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;有一段時間我在分析 java 的 ECKey 的程式碼發現 java 底層的橢圓曲線演算法的實現，這裡我就不做更多的說明了。 &lt;strong&gt;關鍵是我們如何實現分層確定性錢包，這個很簡單也很複雜，其實就是找私鑰 &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; ，至於這個 &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; 怎麼找，我們可以檢視精通比特幣裡面的說明，這裡面只是提到了 HMAC-SHA512。看來這裡面隱藏了很多的細節因素，我們有時間需要研究一下，HMAC-SHA512 的知識了。&lt;/strong&gt;&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">[原文]Base58二進位制到文字編碼被稱為 Base58Check，用於編碼比特幣地址。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/138.png" /></entry><entry><title type="html">什麼是Secp256k1</title><link href="http://localhost:4000/news/2019/11/18/%E4%BB%80%E9%BA%BC%E6%98%AFsecp256k1/" rel="alternate" type="text/html" title="什麼是Secp256k1" /><published>2019-11-18T00:00:00+08:00</published><updated>2019-11-18T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/18/%E4%BB%80%E9%BA%BC%E6%98%AFsecp256k1</id><content type="html" xml:base="http://localhost:4000/news/2019/11/18/%E4%BB%80%E9%BA%BC%E6%98%AFsecp256k1/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/什么是Secp256k1&quot;&gt;[原文]&lt;/a&gt;&lt;strong&gt;secp256k1 是指比特幣中使用的 ECDSA 曲線的參數&lt;/strong&gt; ，並且在高效密碼學標準（SEC）（Certicom Research，&lt;a href=&quot;http://www.secg.org/sec2-v2.pdf&quot;&gt;文件&lt;/a&gt;）中進行了定義。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;p&gt;在比特幣開始流行之前，secp256k1 幾乎從未使用過，但由於其幾個不錯的屬性，它現在越來越受歡迎。大多數常用曲線具有隨機結構，但 secp256k1 是以特殊的非隨機方式構建的，可以實現特別高效的計算。 &lt;strong&gt;因此，如果實施得到充分優化，它通常比其他曲線快 30％ 以上&lt;/strong&gt; 。 &lt;strong&gt;另外，與流行的NIST曲線不同，secp256k1 的常量是以可預測的方式選擇的，這大大降低了曲線建立者在曲線中插入任何後門的可能性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面看一下這裡面的函數圖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/136.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Secp256k1 是 secp256k1 橢圓曲線&lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + 7&lt;/script&gt;在實數上的圖形。請注意，因為 secp256k1 實際上是在欄位&lt;script type=&quot;math/tex&quot;&gt;Zp&lt;/script&gt;上定義的，所以它的圖形實際上看起來像是隨機分散的點，而不是像圖中這樣是連續的點。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;技術細節&quot;&gt;技術細節&lt;/h2&gt;

&lt;p&gt;從標準摘錄：&lt;/p&gt;

&lt;p&gt;與 Koblitz 曲線 secp256k1 相關聯的&lt;script type=&quot;math/tex&quot;&gt;Fp&lt;/script&gt;上的橢圓曲線域參數由單元&lt;script type=&quot;math/tex&quot;&gt;T=（p，a，b，G，n，h）&lt;/script&gt;指定，其中有限域&lt;script type=&quot;math/tex&quot;&gt;Fp&lt;/script&gt;由下式定義：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F
= 2256 - 232 - 29 - 28 - 27 - 26 - 24 - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;Fp&lt;/script&gt;上的曲線E：&lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + ax + b&lt;/script&gt;由下式定義：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;壓縮形式的基點&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在未壓縮的形式是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最後，&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;的迴圈因子&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;(就是指&lt;script type=&quot;math/tex&quot;&gt;nG=G&lt;/script&gt;)和輔因子&lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt;如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141
h = 01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;屬性&quot;&gt;屬性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;secp256k1 具有特徵&lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;，它的素數域定義為 ℤp。常用的一些其他曲線具有特徵2，並且在二進位制伽羅瓦(Galois)域&lt;script type=&quot;math/tex&quot;&gt;GF(2n)&lt;/script&gt;上定義，但 secp256k1 不是其中之一。&lt;/li&gt;
  &lt;li&gt;因為一個常數為零，曲線方程中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ax&lt;/code&gt; 項始終為零，因此曲線方程變為&lt;script type=&quot;math/tex&quot;&gt;y^2 = x^3 + 7&lt;/script&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;也可以看看&quot;&gt;也可以看看&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://bitcoin.stackexchange.com/questions/21907/what-does-the-curve-used-in-bitcoin-secp256k1-look-like&quot;&gt;secp256k1是什麼&lt;/a&gt;（ Pieter Wuille 的比特幣堆棧交換答案）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原文&quot;&gt;原文&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.bitcoin.it/wiki/Secp256k1&quot;&gt;Secp256k1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">[原文]secp256k1 是指比特幣中使用的 ECDSA 曲線的參數 ，並且在高效密碼學標準（SEC）（Certicom Research，文件）中進行了定義。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/137.png" /></entry><entry><title type="html">如何創建你的Pull Request(PR)給密碼龐克台灣</title><link href="http://localhost:4000/news/2019/11/18/%E5%A6%82%E4%BD%95%E5%89%B5%E5%BB%BA%E4%BD%A0%E7%9A%84Pull-Request-%E7%B5%A6%E5%AF%86%E7%A2%BC%E9%BE%90%E5%85%8B%E5%8F%B0%E7%81%A3/" rel="alternate" type="text/html" title="如何創建你的Pull Request(PR)給密碼龐克台灣" /><published>2019-11-18T00:00:00+08:00</published><updated>2019-11-18T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/18/%E5%A6%82%E4%BD%95%E5%89%B5%E5%BB%BA%E4%BD%A0%E7%9A%84Pull%20Request%20%E7%B5%A6%E5%AF%86%E7%A2%BC%E9%BE%90%E5%85%8B%E5%8F%B0%E7%81%A3</id><content type="html" xml:base="http://localhost:4000/news/2019/11/18/%E5%A6%82%E4%BD%95%E5%89%B5%E5%BB%BA%E4%BD%A0%E7%9A%84Pull-Request-%E7%B5%A6%E5%AF%86%E7%A2%BC%E9%BE%90%E5%85%8B%E5%8F%B0%E7%81%A3/">&lt;blockquote&gt;
  &lt;p&gt;PR 即為 Pull Request，在 Github 上必須先複製（Fork）一份原作的專案到你自己的 GitHub 帳號底下。
那自己的 Fork 專案想怎麼玩就怎麼玩，之後你就可以推上自己的 Fork 文件上，發個通知給 Cypherpunks-core，讓團隊人員來審視這次的 PR 是否 ok，若是 ok 則會將您發起的 PR 合併進團隊文章裡，若不 ok 將會在底下描述為何沒通過的理由。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/cypherpunks-core/cypherpunks-core.github.io&quot;&gt;密碼龐克台灣 Github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;750&quot; src=&quot;/img/panda-23.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖1 密碼龐克台灣官網&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;step1---點擊-fork-將專案複製至自己的遠端儲存庫&quot;&gt;Step1 - 點擊 Fork 將專案複製至自己的遠端儲存庫&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;750&quot; src=&quot;/img/panda-24.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖2 點擊畫面右上角之 Fork &lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;750&quot; src=&quot;/img/panda-25.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖3 即可在自己的遠端資源庫中看到 cypherpunks-core 的專案 &lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;以我為例 就會看到 panda850819 forked from cypherpunks-core …&lt;/p&gt;

&lt;h2 id=&quot;step2---clone-專案下載專案&quot;&gt;Step2 - Clone 專案/下載專案&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;750&quot; src=&quot;/img/panda-26.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖4 在自己的專案中按下 Clone 到自己的資料夾 &lt;/strong&gt;&lt;/center&gt;

&lt;ol&gt;
  &lt;li&gt;可以透過 Download ZIP 至你想要的位置解壓縮它&lt;/li&gt;
  &lt;li&gt;可以透過終端機指令，請先開啟終端機並且輸入底下指令&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd desktop &amp;amp;&amp;amp; mkdir cypherpunks-core &amp;amp;&amp;amp; cd cypherpunks-core

// 先將位置移動至桌面並且創立 cypherpunks-core 資料夾

$ git clone https://github.com/{你的github名稱}/cypherpunks-core.github.io.git

// 將專案下載至 cypherpunks-core 資料夾
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;step3---同步-cypherpunks-core-專案&quot;&gt;Step3 - 同步 Cypherpunks-core 專案&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步遠端專案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote -v

// origin https://github.com/panda850819/cypherpunks-core.github.io.git (fetch)
// origin https://github.com/panda850819/cypherpunks-core.github.io.git (push)

$ git remote add upstream https://github.com/cypherpunks-core/cypherpunks-core.github.io.git

$ git remote -v 

// origin	https://github.com/panda850819/cypherpunks-core.github.io.git (fetch)
// origin	https://github.com/panda850819/cypherpunks-core.github.io.git (push)
// upstream	https://github.com/cypherpunks-core/cypherpunks-core.github.io.git (fetch)
// upstream	https://github.com/cypherpunks-core/cypherpunks-core.github.io.git (push)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;同步 fork&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完成操作後，本地專案就會同步 Cypherpunk-core 專案中的變化!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git fetch upstream

$ git checkout master 

$ git merge upstream/master

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;step4---提交-pr-至-cypherpunks-core-team&quot;&gt;Step4 - 提交 PR 至 Cypherpunks-Core Team&lt;/h2&gt;

&lt;p&gt;當我們完成修改之後，我們先將修改後的專案推（&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;）到自己的專案中，接下來就是將修改的部分告知 Cypherpunks-Core Team，那就要來提交 PR 拉！&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;記得要先將自己 fork 的專案推上去，才能提交 PR 喔！&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;提交 PR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;750&quot; src=&quot;/img/panda-27.png&quot; /&gt;&lt;/div&gt;
&lt;center&gt;&lt;strong&gt;圖5 - 提交 PR 至 Cypherpunk-core&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;然後可以在上面輸入摘要跟主題，接下來就等著團隊給予回覆囉！&lt;/p&gt;

&lt;h2 id=&quot;小結&quot;&gt;小結&lt;/h2&gt;
&lt;p&gt;透過幾個小小步驟，我們將了解如何 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fork&lt;/code&gt; 專案以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;Clone&lt;/code&gt; 專案，並且繳交自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pull Request&lt;/code&gt; 給 Cypherpunks-Core Team。&lt;/p&gt;

&lt;p&gt;希望大家能一起為這個社群做貢獻，若有任何想要瞭解的也可以至&lt;a href=&quot;https://cypherpunks-core.github.io/&quot;&gt;官方網站&lt;/a&gt;、&lt;a href=&quot;https://www.facebook.com/CypherpunksTW/&quot;&gt;Facebook&lt;/a&gt;觀看我們的文章和我們一起討論，最後 Cypherpunks Taiwan 密碼龐克 為 crypto 文化的聚集地
主題圍繞在 bitcoin 也是開源項目技術探討聚會，廣義的話圍繞在密碼龐克的隱私、加密傳輸、網路自由，若大家對我們有興趣也請不吝嗇的提交 PR 給我們!&lt;/p&gt;

&lt;h2 id=&quot;參考文獻&quot;&gt;參考文獻&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gitbook.tw/chapters/github/pull-request.html&quot;&gt;為你自己學Git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.itread01.com/content/1544771540.html?fbclid=IwAR2s4ATwibiiKRS3DYBnNsaNVuQeedOovTKZyGY9iaVqUukTDZppXzGu35w&quot;&gt;git如何同步fork專案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">PR 即為 Pull Request，在 Github 上必須先複製（Fork）一份原作的專案到你自己的 GitHub 帳號底下。 那自己的 Fork 專案想怎麼玩就怎麼玩，之後你就可以推上自己的 Fork 文件上，發個通知給 Cypherpunks-core，讓團隊人員來審視這次的 PR 是否 ok，若是 ok 則會將您發起的 PR 合併進團隊文章裡，若不 ok 將會在底下描述為何沒通過的理由。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/panda-22.png" /></entry><entry><title type="html">BIP-65 OP_CHECKLOCKTIMEVERIFY</title><link href="http://localhost:4000/news/2019/11/14/BIP-65-OP_CHECKLOCKTIMEVERIFY/" rel="alternate" type="text/html" title="BIP-65 OP_CHECKLOCKTIMEVERIFY" /><published>2019-11-14T00:00:00+08:00</published><updated>2019-11-14T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/14/BIP-65%20OP_CHECKLOCKTIMEVERIFY</id><content type="html" xml:base="http://localhost:4000/news/2019/11/14/BIP-65-OP_CHECKLOCKTIMEVERIFY/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-65%20OP-CHECKLOCKTIMEVERIFY.html&quot;&gt;原文&lt;/a&gt;:BIP-65 OP_CHECKLOCKTIMEVERIFY    &lt;br /&gt;
該BIP為比特幣 script 系統描述了一個新的 OPCode （&lt;code class=&quot;highlighter-rouge&quot;&gt;OP_CHECKLOCKTIMEVERIFY&lt;/code&gt;），該 OPCode 允許交易輸出在未來的某個點之前變得不可花費。&lt;/p&gt;

&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CHECKLOCKTIMEVERIFY 重新定義了現有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP2&lt;/code&gt; OPCode (其實就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_CHECKLOCKTIMEVERIFY&lt;/code&gt; 指令替換了 &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_NOP2&lt;/code&gt; 指令)。執行時，如果以下任何一個條件成立，則 OPCode 直譯器將以錯誤終止：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;堆棧是空的;&lt;/li&gt;
  &lt;li&gt;堆棧中的頂層項目小於0;&lt;/li&gt;
  &lt;li&gt;頂層堆棧項的鎖定時間類型（高度vs.時間戳）與 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位不同;&lt;/li&gt;
  &lt;li&gt;頂部堆棧項大於交易的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;txin&lt;/code&gt;（交易輸入）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nSequence&lt;/code&gt; 欄位是 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffffff&lt;/code&gt; ;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;否則， OPCode 執行將繼續，如同NOP執行一樣。&lt;/p&gt;

&lt;p&gt;交易中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位可防止交易被挖出，直到達到某個區塊高度或區塊時間為止。通過將傳給 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 的參數與 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位進行比較，我們間接驗證是否已達到所需的區塊高度或區塊時間; 直到該區塊高度或區塊時間已經達到，交易輸出仍然不可花費。&lt;/p&gt;

&lt;h2 id=&quot;動機&quot;&gt;動機&lt;/h2&gt;

&lt;p&gt;交易中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位可用於證明 將來可以花費這筆交易輸出，方法是構造一個有效的交易開銷，並對&lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt;欄位進行設定。&lt;/p&gt;

&lt;p&gt;然而， &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位不能證明在未來的某個時間內不可能花費交易輸出，因為無法知道是否建立了支出該輸出的其他交易的有效簽名。&lt;/p&gt;

&lt;h2 id=&quot;第三方託管&quot;&gt;第三方託管&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果 Alice 和 Bob 聯合經營一家企業，他們可能希望確保所有資金都儲存在需要雙方同時批准的 2-of-2 的多重（多重簽名的交易）交易輸出中。但是，他們發現在特殊情況下，例如任何一個人受到“嚴重的車禍”，他們都需要備用的方法，繼續動用該筆資金。因此，他們任命他們的律師 Lenny 擔任第三方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在任何時候，Lenny 隨時可以同 Alice 或 Bob 一起串謀非法竊取資金。同樣，Lenny 可能更願意不竊取資金，以阻止不良行為者企圖強行從他那裡獲取 secret keys 。&lt;/p&gt;

&lt;p&gt;但是，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 可以將資金儲存在以下格式的 scriptPubKeys 中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF
    &amp;lt;now + 3 months&amp;gt; CHECKLOCKTIMEVERIFY DROP
    &amp;lt;Lenny's pubkey&amp;gt; CHECKSIGVERIFY
    1
ELSE
    2
ENDIF
&amp;lt;Alice's pubkey&amp;gt; &amp;lt;Bob's pubkey&amp;gt; 2 CHECKMULTISIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在任何時候，資金都可以用下面的 OPCode 來支付：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 &amp;lt;Alice's signature&amp;gt; &amp;lt;Bob's signature&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lenny 經過 3 個月後，Alice 或 Bob 中的一個可以用以下 OPCode 支付資金：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 &amp;lt;Alice/Bob's signature&amp;gt; &amp;lt;Lenny's signature&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;非交互式定期退款--non-interactive-time-locked-refunds&quot;&gt;非交互式定期退款 | Non-interactive time-locked refunds&lt;/h2&gt;

&lt;p&gt;存在許多協議，其中建立交易輸出，這需要雙方的合作來花費輸出。為確保一方的失敗不會導致資金損失，退款交易使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 提前設定。這些退款交易需要互動式建立，此外，目前易受交易延展性影響。 ` CHECKLOCKTIMEVERIFY` 可用於這些協議，用非互動式設定取代互動式設定，另外，使交易延展性不成問題。&lt;/p&gt;

&lt;h3 id=&quot;雙因素錢包--two-factor-wallets&quot;&gt;雙因素錢包 | Two-factor wallets&lt;/h3&gt;

&lt;p&gt;諸如 GreenAddress 之類的服務將比特幣儲存為 2-of-2 的多重簽名 OPCode ScriptPubKey，使得一個金鑰對由使用者控制，另一個金鑰對由服務控制。為了花費資金，使用者使用本地安裝的生成所需簽名之一的錢包軟體，然後使用雙因素身份驗證方法來授權該服務建立第二個 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGHASH_NONE&lt;/code&gt; 簽名，該簽名在將來的某個時間被鎖定，並向用戶傳送該儲存簽名。如果使用者需要花費資金並且服務不可用，他們會等到 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 過期。&lt;/p&gt;

&lt;p&gt;問題是，在許多情況下，使用者將不會擁有一些或全部交易輸出的有效簽名。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 而不是按需建立退款簽名，而是使用以下形式的 scriptPubKeys ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF
    &amp;lt;service pubkey&amp;gt; CHECKSIGVERIFY
ELSE
    &amp;lt;expiry time&amp;gt; CHECKLOCKTIMEVERIFY DROP
ENDIF
&amp;lt;user pubkey&amp;gt; CHECKSIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現在，用戶總是可以通過等待到期時間來花費他們的資金而無需服務的合作。&lt;/p&gt;

&lt;h3 id=&quot;支付通道--payment-channels&quot;&gt;支付通道 | Payment Channels&lt;/h3&gt;

&lt;p&gt;傑里米·斯皮爾曼（ Jeremy Spilman ）style 的支付通道首先設定一個存款，由 2-of-2 的多重簽名， tx1 控制的存款，然後調整第二個交易 tx2 ，將 tx1 的輸出用於支付者和收款者。在釋出 tx1 之前，建立一個退款交易 tx3 ，確保收款人消失時付款人可以取回其押金。當前創建退款交易的過程容易受到交易延展性攻擊的影響，此外，還要求付款人儲存退款。使用與雙因素錢包示例中相同的 scriptPubKey 形式可以解決這兩個問題。&lt;/p&gt;

&lt;h2 id=&quot;發布數據的無信任付款--trustless-payments-for-publishing-data&quot;&gt;發布數據的無信任付款 | Trustless Payments for Publishing Data&lt;/h2&gt;

&lt;p&gt;The PayPub protocol makes it possible to pay for information in a trustless way by first proving that an encrypted file contains the desired data, and secondly crafting scriptPubKeys used for payment such that spending them reveals the encryption keys to the data. However the existing implementation has a significant flaw: the publisher can delay the release of the keys indefinitely.&lt;/p&gt;

&lt;p&gt;This problem can be solved interactively with the refund transaction technique; with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using scriptPubKeys of the following form:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;通過首先證明加密文件包含所需的數據，然後製作用於支付的 scriptPubKeys 以便使它們花費來顯示數據的加密密鑰，PayPub 協議可以以不信任的方式支付信息。但是，現有的實現存在一個重大缺陷：發布者可以無限期地延遲密鑰的發布。&lt;/p&gt;

&lt;p&gt;這個問題可以用退款交易技術互動地解決; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; ，可以使用以下形式的scriptPubKeys以非互動方式解決問題：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF
    HASH160 &amp;lt;Hash160(encryption key)&amp;gt; EQUALVERIFY
    &amp;lt;publisher pubkey&amp;gt; CHECKSIG
ELSE
    &amp;lt;expiry time&amp;gt; CHECKLOCKTIMEVERIFY DROP
    &amp;lt;buyer pubkey&amp;gt; CHECKSIG
ENDIF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;資料的買家現在正在提供一個有效期限的安全報價。如果發行商在到期時間到期之前未能接受報價，買家可以通過消費輸出來取消報價。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;證明犧牲礦工的手續費--proving-sacrifice-to-miners-fees&quot;&gt;證明犧牲礦工的手續費 | Proving sacrifice to miners’ fees&lt;/h2&gt;

&lt;p&gt;Proving the sacrifice of some limited resource is a common technique in a variety of cryptographic protocols. Proving sacrifices of coins to mining fees has been proposed as a universal public good to which the sacrifice could be directed, rather than simply destroying the coins. However doing so is non-trivial, and even the best existing technqiue - announce-commit sacrifices - could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to create outputs that are provably spendable by anyone (thus to mining fees assuming miners behave optimally and rationally) but only at a time sufficiently far into the future that large miners can’t profitably sell the sacrifices at a discount.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;證明犧牲一些有限的資源是各種密碼協議中的常用技術。已經提出了證明將硬幣犧牲為採礦費的做法，作為犧牲品可以針對的一種普遍的公共物品，而不是簡單地銷毀硬幣。但是，這樣做並非易事，即使是現有的最佳技術-宣布承諾犧牲-也會鼓勵採礦業的集中化。  &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 可用於創建任何人都可證明可使用的輸出（因此，假設礦工的行為合理且合理，則要收取採礦費），但前提是在足夠遠的將來，大型礦工無法以折扣價出售利潤。&lt;/p&gt;

&lt;p&gt;證明犧牲一些有限的資源是各種密碼協議中的常見技術。已經提出將幣的犧牲證明為挖礦手續費，作為犧牲可以指向的普遍公共物品，而不是簡單地摧毀幣。然而，這樣做並非微不足道，即使是最好的現有技術 - 宣佈 - 承諾 - 也會鼓勵礦業集中。 &lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; 可用於建立任何人都可以花費的產出（因此，假設礦工的行為是理想的和理性的，那麼開採費），但只有在未來足夠遠的時間，大型礦工才能以折扣銷售犧牲品。&lt;/p&gt;

&lt;h2 id=&quot;凍結資金--freezing-funds&quot;&gt;凍結資金 | Freezing Funds&lt;/h2&gt;

&lt;p&gt;除了使用冷儲存，硬體錢包和 P2SH multisig 輸出來控制資金之外，現在資金可以直接在區塊鏈中凍結在 UTXO 中。使用下面的 scriptPubKey ，在提供的失效時間之前，沒有人能夠使用安全輸出。這種可靠地凍結資金的能力在需要減少脅迫或沒收風險的情況下可能會有用。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;expiry time&amp;gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &amp;lt;pubKeyHash&amp;gt; EQUALVERIFY CHECKSIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;完全替換nlocktime欄位--replacing-the-nlocktime-field-entirely&quot;&gt;完全替換nLockTime欄位 | Replacing the nLockTime field entirely&lt;/h2&gt;

&lt;p&gt;另外，請注意如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;SignatureHash()&lt;/code&gt; 演算法可以選擇覆蓋 OPCode 的一部分，那麼簽名可能會要求 OPCode Sig包含&lt;code class=&quot;highlighter-rouge&quot;&gt;CHECKLOCKTIMEVERIFY&lt;/code&gt; OPCode ，並且還需要執行它們。（ CODESEPARATOR OPCode 非常接近於在比特幣的 v0.1 中實現這一點）。這種每簽名功能可以完全取代每個交易的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt; 欄位，因為有效簽名現在可以證明交易輸出可以花費。&lt;/p&gt;

&lt;h2 id=&quot;詳細規格--detailed-specification&quot;&gt;詳細規格 | Detailed Specification&lt;/h2&gt;

&lt;p&gt;參考下面轉載的參考實現，瞭解這些語義的精確語義和詳細基本原理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case OP_NOP2:
case OP_NOP2:
{
    // CHECKLOCKTIMEVERIFY
    //
    // (nLockTime -- nLockTime )

    if (!(flags &amp;amp; SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))
        break; // not enabled; treat as a NOP

    if (stack.size() &amp;lt; 1)
        return false;

    // Note that elsewhere numeric opcodes are limited to
    // operands in the range -2**31+1 to 2**31-1, however it is
    // legal for opcodes to produce results exceeding that
    // range. This limitation is implemented by CScriptNum's
    // default 4-byte limit.
    //
    // If we kept to that limit we'd have a year 2038 problem,
    // even though the nLockTime field in transactions
    // themselves is uint32 which only becomes meaningless
    // after the year 2106.
    //
    // Thus as a special case we tell CScriptNum to accept up
    // to 5-byte bignums, which are good until 2**32-1, the
    // same limit as the nLockTime field itself.
    const CScriptNum nLockTime(stacktop(-1), 5);

    // In the rare event that the argument may be &amp;lt; 0 due to
    // some arithmetic being done first, you can always use
    // 0 MAX CHECKLOCKTIMEVERIFY.
    if (nLockTime &amp;lt; 0)
        return false;

    // There are two types of nLockTime: lock-by-blockheight
    // and lock-by-blocktime, distinguished by whether
    // nLockTime &amp;lt; LOCKTIME_THRESHOLD.
    //
    // We want to compare apples to apples, so fail the script
    // unless the type of nLockTime being tested is the same as
    // the nLockTime in the transaction.
    if (!(
            (txTo.nLockTime &amp;lt;  LOCKTIME_THRESHOLD &amp;amp;&amp;amp; nLockTime &amp;lt;  LOCKTIME_THRESHOLD) ||
            (txTo.nLockTime &amp;gt;= LOCKTIME_THRESHOLD &amp;amp;&amp;amp; nLockTime &amp;gt;= LOCKTIME_THRESHOLD)
            ))
        return false;

    // Now that we know we're comparing apples-to-apples, the
    // comparison is a simple numeric one.
    if (nLockTime &amp;gt; (int64_t)txTo.nLockTime)
        return false;

    // Finally the nLockTime feature can be disabled and thus
    // CHECKLOCKTIMEVERIFY bypassed if every txin has been
    // finalized by setting nSequence to maxint. The
    // transaction would be allowed into the blockchain, making
    // the opcode ineffective.
    //
    // Testing if this vin is not final is sufficient to
    // prevent this condition. Alternatively we could test all
    // inputs, but testing just this input minimizes the data
    // required to prove correct CHECKLOCKTIMEVERIFY execution.
    if (txTo.vin[nIn].IsFinal())
        return false;

    break;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4&lt;/p&gt;

&lt;h2 id=&quot;部署--deployment&quot;&gt;部署 | Deployment&lt;/h2&gt;

&lt;p&gt;我們重用BIP66中使用的雙閾值 &lt;code class=&quot;highlighter-rouge&quot;&gt;IsSuperMajority()&lt;/code&gt; 切換機制，其閾值相同，但 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion = 4&lt;/code&gt; 。新規則對於 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion = 4&lt;/code&gt; 的每個區塊（高度為H）有效，並且至少有750之前的區塊（高度為H-1000..H-1）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;gt;= 4&lt;/code&gt; 。此外，當區塊之前的1000個區塊中的950個具有 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;gt;= 4&lt;/code&gt; 時， &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;lt; 4&lt;/code&gt; 區塊將變為無效，並且全部進一步的阻止執行新的規則。&lt;/p&gt;

&lt;p&gt;應該注意的是，BIP9涉及永久性地將高位設定為1，這導致 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&amp;gt;=&lt;/code&gt; 所有先前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;IsSuperMajority()&lt;/code&gt; 軟分叉，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; 中的位不會永久丟失。&lt;/p&gt;

&lt;h2 id=&quot;spv客戶--spv-clients&quot;&gt;SPV客戶 | SPV Clients&lt;/h2&gt;

&lt;p&gt;儘管SPV客戶端（當前）通常無法驗證區塊，而是信任礦工對其進行驗證，但他們能夠驗證區塊頭，因此可以驗證部署規則的子集。如果達到95％閾值時，前1000個區塊中的950個中有950個具有 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion &amp;gt;= 4&lt;/code&gt; ，則SPV客戶端應拒絕 &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion 4&lt;/code&gt; 區塊，以防止來自剩餘未升級礦工的5％的錯誤確認。&lt;/p&gt;

&lt;h2 id=&quot;credits&quot;&gt;Credits&lt;/h2&gt;
&lt;p&gt;Thanks goes to Gregory Maxwell for suggesting that the argument be compared against the per-transaction nLockTime, rather than the current block height and time.&lt;/p&gt;

&lt;h2 id=&quot;參考&quot;&gt;參考&lt;/h2&gt;

&lt;p&gt;PayPub&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/unsystem/paypub&quot;&gt;https://github.com/unsystem/paypub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jeremy Spilman支付通道&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html&quot;&gt;https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;實現&quot;&gt;實現&lt;/h2&gt;

&lt;p&gt;Python / python-bitcoinlib&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/petertodd/checklocktimeverify-demos&quot;&gt;https://github.com/petertodd/checklocktimeverify-demos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript / Node.js / bitcore&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mruddy/bip65-demos&quot;&gt;https://github.com/mruddy/bip65-demos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;版權--copyright&quot;&gt;版權 | Copyright&lt;/h2&gt;

&lt;p&gt;This document is placed in the public domain.&lt;/p&gt;

&lt;h2 id=&quot;引用和參考&quot;&gt;引用和參考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.chidaolian.com/article-680-4&quot;&gt;BIP65：檢查鎖定時間驗證&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki&quot;&gt;bips/bip-0065.mediawiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文:BIP-65 OP_CHECKLOCKTIMEVERIFY 該BIP為比特幣 script 系統描述了一個新的 OPCode （OP_CHECKLOCKTIMEVERIFY），該 OPCode 允許交易輸出在未來的某個點之前變得不可花費。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/135.jpg" /></entry><entry><title type="html">基於數位浮水印和區塊鏈的版權管理系統設計方案</title><link href="http://localhost:4000/news/2019/11/13/%E7%BF%BB%E8%AD%AF-%E5%9F%BA%E6%96%BC%E6%95%B8%E4%BD%8D%E6%B5%AE%E6%B0%B4%E5%8D%B0%E5%92%8C%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E7%89%88%E6%AC%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88%E6%96%B9%E6%A1%88/" rel="alternate" type="text/html" title="基於數位浮水印和區塊鏈的版權管理系統設計方案" /><published>2019-11-13T00:00:00+08:00</published><updated>2019-11-13T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/13/%E7%BF%BB%E8%AD%AF:%E5%9F%BA%E6%96%BC%E6%95%B8%E4%BD%8D%E6%B5%AE%E6%B0%B4%E5%8D%B0%E5%92%8C%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E7%89%88%E6%AC%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88%E6%96%B9%E6%A1%88</id><content type="html" xml:base="http://localhost:4000/news/2019/11/13/%E7%BF%BB%E8%AD%AF-%E5%9F%BA%E6%96%BC%E6%95%B8%E4%BD%8D%E6%B5%AE%E6%B0%B4%E5%8D%B0%E5%92%8C%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E7%89%88%E6%AC%8A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88%E6%96%B9%E6%A1%88/">&lt;blockquote&gt;
  &lt;p&gt;本篇文章翻譯自 &lt;a href=&quot;https://ieeexplore-ieee-org.autorpa.lib.nkust.edu.tw/document/8377886/references#references&quot;&gt;Design Scheme of Copyright Management System Based on Digital Watermarking and Blockchain&lt;/a&gt; 的內容，數位浮水印概念我們從圖像、影像..等，已經玩了許久當他結合區塊鏈又會產生什麼火花呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;摘要&quot;&gt;摘要:&lt;/h1&gt;

&lt;p&gt;過去，基於數位浮水印的數位版權保護系統主要在改進演算法效率上，而忽略浮水印訊息的生成和儲存空間。在本論文提出一個全新且基於數位浮水印和訊息的區塊鏈版權管理系統之設計機制，它結合數位浮水印、區塊鏈、感知雜湊、QR code 和星際檔案系統（IPFS）。其中，區塊鏈用於安全儲存浮水印訊息，並為多個浮水印（多個版權）提供時間戳認證，以確認創建順序。感知雜湊用於基於圖像的結構信息生成雜湊，無需原始圖像即可確認浮水印訊息。QR code 用於生成包含圖像之雜湊和版權訊息作為浮水印圖像的 QR Code，以提高數位浮水印的強韌性和容量；IPFS 在沒中心伺服器的情況下儲存和分散浮水印的圖像。該機制可以增強數位浮水印技術在版權保護領域的有效性。透過這種方式，可以使用 P2P 網路來集成並完成版權管理和版權作品的出版，而無需受信任的第三方。節點依靠密碼學來確認彼此的身份並確保訊息之安全性。它可以減少訊息洩露，數據破壞和造成過去的集中式系統崩潰等風險。這提高了訊息的安全性和透明度，並加快了受版權保護作品的出版，以促進網路中的流通。該方案還可以改善多個創作之版權保護。結合區塊鏈和多個數位浮水印，在創作過程中記錄每個版權所有者的版權訊息並充分證明，為了保護每個版權所有者的合法權益。&lt;/p&gt;

&lt;h1 id=&quot;第一章節---介紹&quot;&gt;第一章節 - 介紹&lt;/h1&gt;

&lt;p&gt;隨著數位科技和互聯網之發展，以圖像、音頻、影像和其他數位格式的多媒體和數位作品已經在互聯網上發布，其版權保護和訊息完整性保證已逐漸成為迫切需要解決的問題。由於數位作品易於複製、處理、傳播和公開，因此竊盜者利用數位作品的這些特徵破壞版權擁有者的合法權利以獲得個人利益。&lt;/p&gt;

&lt;p&gt;數位浮水印技術可用於數位版權之保護 [1] [2] [3]。它可以將一些重要機密訊息（例如版權所有者的個人信息）添加到數位作品中，且不會被數位作品使用者察覺。此外，嵌入式數位浮水印可與數位作品的副本一起複製，在實際應用中更加方便有效。但是數位浮水印技術在訊息的儲存和認證、強韌性和儲存空間以及其他方面仍有改進的空間。&lt;/p&gt;

&lt;p&gt;除虛擬貨幣外，近年來，區塊鏈技術已開始在其他領域擴展，包括數位版權保護。[4] [5] [6]。為了保護傳統的版權，版權所有者需要向註冊機構提供數位作品和一些個人訊息作為版權訊息。中心化機構將手動檢查提交的訊息並將其存儲在中心化伺服器中。這不僅導致效率低下和成本增加，而且還存在訊息被篡改和洩漏的風險。同時，這也給版權驗證者進行數位取證帶來了很多麻煩，因為有必要證明該訊息確實是原始訊息且不得更改。對於此方案，將使用區塊鏈儲存版權信息，並將訊息寫入區塊鏈後，將很難更改它。這將極大化促進版權驗證者的數位取證。在實際應用中，區塊鏈還可以幫助確認多個浮水印（多個版權），因為每個區塊都包含不可更改的時間戳記。如果獲得了所有浮水印訊息，即可在區塊鏈中搜索相應的區塊並檢查時間戳記。可以知道多個浮水印的嵌入順序，換句話說，可以知道數位圖像的創建順序。&lt;/p&gt;

&lt;p&gt;將圖像直接存儲在區塊鏈中是不切實際的。一種更實用、更方便的方法是對圖像進行雜湊處理，在區塊鏈中記錄這些圖像的雜湊值，然後將圖像文件儲存在其他位置以供調用。然而，對於圖像、文件之類的多媒體文件，使用 MD5 和 SHA256 之類的傳統密碼雜湊演算法並不是很合適 [7]。&lt;/p&gt;

&lt;p&gt;因為除了篡改內容外，圖像還將經歷正常的操作，例如添加數位浮水印、過濾、旋轉、壓縮等。這些操作不會引起圖像內容的變化，因此不會引起人體感覺系統產生感覺差異，當然這些圖像仍然被人類視為同一圖像。&lt;/p&gt;

&lt;p&gt;但是，此圖像的數據結構已被電腦更改，因此傳統雜湊函數的計算結果將完全不同。顯然，這不是我們想要看到的結果，因此它需要一種對內容操作具有強韌性並且對內容篡改敏感的新雜湊算法。&lt;/p&gt;

&lt;p&gt;感知雜湊函數在計算雜湊值之前對圖像執行一系列處理，例如減小大小和簡化顏色，刪除圖像的細節以及保留這些圖像的結構信息[7]。&lt;/p&gt;

&lt;p&gt;只要某個圖像的結構沒有改變，雜湊就不會改變 [8] [9]。
換句話說，在將數位浮水印添加到原始圖像後，結構信息將不會更改通過相同的感知雜湊函數計算浮水印圖像，並將計算出的雜湊值與提取的數位浮水印訊息進行比較。換句話說，在將數位浮水印添加到原始圖像後，通過相同的感知哈希函數計算水印圖像後，結構信息將不會更改。換句話說，在將數位浮水印添加到原始圖像，通過相同的感知雜湊函數計算浮水印圖像並將計算出的雜湊值與提取的數位浮水印信息進行比較之後，結構信息將不會改變。這樣，可以在沒有原始圖像的情況下對帶有浮水印的數位圖像進行自我認證[10] [11]。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-1.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖1 方案示意圖&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;就用於版權保護的數位浮水印技術而言，對其強韌性的要求實際上非常高 [1][2][3]。不僅要求在一系列操作或攻擊之後可以檢測並提取數位浮水印，而且還要求提取的數位浮水印應清晰可辨，以確認版權信息。另外，浮水印空間也是一個重要特徵，因為它必須具有足夠的版權信息才能發揮版權保護的作用。對於這兩點，QR Code 圖像可用作數位浮水印圖像[12][13][14][15]。&lt;/p&gt;

&lt;p&gt;首先，QR Code 具有一定的容錯能力。即使 QR Code 圖像上有污點，機器仍可以讀取。通常，QR Code 圖像的污損區域仍可以在 7％-30％ 的範圍內讀取[12] [13]。這可以有效地提高數位浮水印技術的強韌性。其次，QR Code 可儲存更多信息，這對於提高水印空間非常有幫助。最後，大多數電子設備，尤其是智能手機，都可以識別 QR Code 圖像，並且在實際應用中會很方便。&lt;/p&gt;

&lt;p&gt;與其他傳統網路平台一樣，它需要有一個儲存圖像的位置，供用戶瀏覽和下載。傳統的中心化儲存有很多缺點，例如，它需要大型伺服器儲存。這樣會增加營運成本，並且一旦伺服器斷電或物理損壞和其他嚴重問題，就會影響圖像用戶的使用並帶來很多不便。更嚴重的是，一旦伺服器受到駭客攻擊，它將洩漏或破壞大量重要訊息，從而導致嚴重且不可估量的損失。&lt;/p&gt;

&lt;p&gt;星際檔案系統是點對點分散式文件儲存系統，用於通信協議和內容傳遞之網路[16]。為了便於描述，後面將使用縮寫詞 IPFS 來表示該系統。與 HTTP 不同，IPFS 不再關心中央伺服器的位置，並且不考慮文件名和路徑。它僅注意文件中可能出現的內容。將任何文件放置在 IPFS 節點上之後，將根據該文件的內容計算加密雜湊。當要求 IPFS 提供文件之雜湊時，它使用分散式雜湊表來尋找此文件所在的節點，然後搜索此文件並進行驗證。因此，使用 IPFS 可以大大降低網路平台的運營成本，並提高圖像文件儲存的安全性。此外，IPFS 實現了 HTTP 閘道，圖像用戶可用通用瀏覽器瀏覽任何內容並下載它們。&lt;/p&gt;

&lt;p&gt;本文的其餘部分安排如下。第二章節介紹該方案基於數位浮水印的圖像版權保護系統的組成以及該方案的過程。第三章節介紹了該方案的仿真。最後，第四章節總結了論文。&lt;/p&gt;

&lt;h1 id=&quot;第二章節---基於數位浮水印技術之改進數位圖像版權保護系統&quot;&gt;第二章節 - 基於數位浮水印技術之改進數位圖像版權保護系統&lt;/h1&gt;

&lt;p&gt;圖1 為該方案的示意圖。 首先在 A 小節中詳細介紹該方案的具體組件。圖中標誌的序列號是該系統的實現順序，將會在 B 小節中描述該方案的過程。&lt;/p&gt;

&lt;h2 id=&quot;a-計畫的組成&quot;&gt;A. 計畫的組成&lt;/h2&gt;

&lt;p&gt;該方案的組成部分可以分為兩部分。數位浮水印系統的第一部分包括雜湊生成、區塊鏈儲存、數位浮水印之圖像生成和數位浮水印嵌入。第二部分是關於含有浮水印的圖像和版權訊息的儲存和傳播。首先介紹第一部分，如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;感知雜湊函數將用於計算圖像的雜湊值作為圖像的 ID 號。其目的是在嵌入數位浮水印前和嵌入數位浮水印後，此圖像的雜湊值將不會更改。為了確保沒有原始圖像仍然可以驗證浮水印訊息。由於感知雜湊函數的這一特性，為了確保原始圖像和浮水印圖像不會混淆，還需要使用傳統的密碼雜湊函數。利用加密雜湊函數的特性，即在添加浮水印之前和之後對數據進行修改的敏感性，對兩個圖像進行加密雜湊計算，以證明它們之間的順序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;區塊鏈技術用於儲存有關圖像的訊息，如圖 1 所示，圖像的感知雜湊值，圖像所有者的訊息等。由於區塊鏈本質上是一個去中心化的數據庫，因此它可以通過&lt;strong&gt;加密&lt;/strong&gt;來相互驗證彼此的身份並安全地儲存沒有受信任的第三方的數據。區塊鏈網路中的每個節點都可以備份完整的區塊鏈數據，並且節點之間不知道彼此的真實身份。這大大降低了節點之間發生&lt;strong&gt;合夥篡改&lt;/strong&gt;數據的風險。在實際應用中，面對多個浮水印（多個版權）的問題，可以使用區塊鏈的時間戳記功能來解決。如前所述，關於區塊鏈的安全性，透過時間戳記數據也是不可更改的。獲取浮水印訊息後，可以根據該訊息獲取對應的區塊，以獲得對應的時間訊息，以證明多個浮水印之序列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有必要訊息都記錄在區塊鏈上後，這是第一部分的最後階段，即數位浮水印的生成和嵌入。為了提高數位浮水印的強韌性和攜帶的信息量，使用 QR Code 生成浮水印圖像。此 QR code 圖像包含記錄在區塊鏈中的擁有者的數位簽章。 為了提高數位浮水印的強韌性，浮水印嵌入過程採用基於&lt;strong&gt;頻率域&lt;/strong&gt;的數位浮水印嵌入方法。這裡使用的空頻域變換方法是離散餘弦變換（DCT）。具體方法將在第三章節中介紹。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;數位浮水印系統的工作已經結束，並將包含擁有者的數位簽章訊息的數位浮水印嵌入到原始圖像中。接下來是圖像用戶部分。該方案的第二部分如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;為了解決集中式伺服器中可能出現的問題，IPFS 用於儲存和傳播帶浮水印的圖像。將一個文件夾上傳到 IPFS 網路，該文件夾包括一個帶浮水印的圖像，以及一個文本文件，其中包含有關其相應區塊的訊息，該文件包含該區塊的&lt;strong&gt;索引&lt;/strong&gt;、該圖像的&lt;strong&gt;標題&lt;/strong&gt;，擁有者的名稱和電子郵件地址等。可以通過常見的瀏覽器瀏覽圖像和相關訊息，然後下載它們。具體操作也將在第三節中演示。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;b-計畫流程&quot;&gt;B. 計畫流程&lt;/h2&gt;

&lt;p&gt;如 圖1 中的（1）-（5）所示，該方案的具體過程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上傳原始圖像，然後提交一些版權擁有者的訊息和其他中介資料，例如真實姓名、電子郵件地址、圖片標題。 然後使用感知雜湊函數計算該圖像的感知雜湊值。 並使用加密雜湊函數來計算此原始圖像的加密雜湊值作為數位簽章。&lt;/li&gt;
  &lt;li&gt;感知雜湊值，版權擁有者的訊息和其他中介資料作為版權擁有者的數位簽章。 結合加密雜湊值，它們被用作交易的附加訊息，以向區塊鏈網路發起交易請求，並將這些記錄在區塊鏈中。&lt;/li&gt;
  &lt;li&gt;生成包含版權擁有者的數位簽章的 QR Code 圖像。 即感知雜湊值，版權擁有者的訊息和其他中介資料。&lt;/li&gt;
  &lt;li&gt;將此 QR Code 圖像用作數位浮水印圖像，將其嵌入到原始圖像中，並生成已添加數位浮水印的圖像，並使用加密雜湊函數來計算該浮水印圖像的加密雜湊值，並將其記錄在區塊鏈中。&lt;/li&gt;
  &lt;li&gt;將此帶浮水印的圖像文件及其阻止訊息上傳到 IPFS 網路。通過 IPFS 網路瀏覽並下載帶浮水印的圖像及其版權信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;已經引入了 圖1 所示的過程。用戶在獲取圖像後還需要驗證圖像，如下所示：&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用相同的感知雜湊函數來計算此浮水印圖像，並提取浮水印。將計算出的雜湊值，數位浮水印中的雜湊值和區塊鏈中的雜湊值相互比較以確定版權。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，完整的過程結束了。前面提到的多個浮水印問題，即每個圖像修改器都要經過步驟（1）-（5），最終形成一個包含多個數位浮水印的數位圖像。 然後，在步驟（6）中，提取所有數位浮水印，並基於浮水印訊息檢索相應的區塊以獲得時間戳記訊息。 最後，證明了數位浮水印的嵌入順序和數位圖像的創建順序。&lt;/p&gt;

&lt;h1 id=&quot;第三章節---計畫實驗&quot;&gt;第三章節 - 計畫實驗&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;仿真圖像為lena.jpg，如圖2所示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-2.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖2 原始 lena.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;a-計算圖像之雜湊值&quot;&gt;A. 計算圖像之雜湊值&lt;/h2&gt;

&lt;p&gt;在感知雜湊函數中，基本上有四個類別，即平均雜湊（AHA），差異雜湊（DHA），感知哈希（PHA）和小波雜湊（WHA）[12]。 由於仿真中 DHA的結果最好且誤差最小，因此選擇 DHA 進行實驗。 如圖3所示，lena.jpg 的哈希值是 6e0egedaccc85a1c。為了證明嵌入數位浮水印後圖像的變化，請使用 MD5 計算 lena.jpg，如圖4所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-3.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖3 lena.jpg 之雜湊值&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-4.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖4 使用 MD5 計算 lena.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;b-區塊鏈的產生&quot;&gt;B. 區塊鏈的產生&lt;/h2&gt;

&lt;p&gt;為了便於演示，透過 GitHub [17] [18] [19] [20] 上的區塊鏈程式，撰寫一個區塊鏈程式來模擬滿足此方案要求的區塊鏈功能。 然後使用網站 https://www.getpostman.com/ 提供的 Postman 進行接口請求測試並讀取區塊鏈中的數據。如 圖5 所示，啟動了區塊鏈網路中的一個節點。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-5.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖5 在區塊鏈網路中跑節點&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;如圖6所示，lena.jpg 的雜湊值和版權擁有者訊息作為附加訊息添加到交易中，然後將交易之應用程序啟動到區塊鏈網路。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-6.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖6 增加交易資訊至區塊中&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;區塊鏈網路中的節點將透過挖礦生成一個新區塊，如圖7所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-7.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖7 挖礦和生成區塊&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;經過其他節點確認後，新生成的區塊將添加到合法的區塊鏈中，如圖8所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-8.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖8 合法的區塊鏈&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;c-生成-qr-code-圖像&quot;&gt;C. 生成 QR Code 圖像&lt;/h2&gt;

&lt;p&gt;由於仿真圖像的尺寸為512 * 512，因此必須在可以讀取 QR Code 訊息的前提下限制 QR Code 圖像的尺寸。 所有參數盡量選擇最小的一個。 如 圖9 所示，使用該圖像的雜湊值和版權擁有者的訊息生成一個64 * 64  QR Code 圖像。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-9.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖9 QR Code 圖像 mark.png&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;d-嵌入和萃取數位浮水印&quot;&gt;D. 嵌入和萃取數位浮水印&lt;/h2&gt;

&lt;p&gt;使用 MATLAB 編寫基於離散餘弦變換（DCT）的頻率域數位浮水印算法進行仿真，並使用其逆變換（IDCT）提取浮水印[21] [22] [23]。這裡使用二維 DCT 和二維 IDCT。 F（μ，v）和 f（x，y）分別是 DCT 和IDCT 的&lt;strong&gt;變換係數&lt;/strong&gt;。c（μ）和 c（v）是&lt;strong&gt;相加係數&lt;/strong&gt;，其主要作用是使 DCT 和 IDCT 變換矩陣成為正交矩陣。如公式（1）、（2）和（3）所示。&lt;/p&gt;

&lt;p&gt;如圖10 和 11 所示，它們分別是浮水印圖像 lena_marked.jpg 和萃取的數位浮水印 markout.png。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-10.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖10 浮水印圖像 lena_marked.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-11.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖11 萃取數位浮水印 markout.png&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;和以前一樣，使用 MD5 計算帶浮水印的圖像 lena_marker.jpg。儘管兩個圖像看起來相同，但 MD5 值已更改，如圖12 所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-12.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖12 lena_marked.jpg 之 MD5 值&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;e-上傳和儲存圖像檔案及版權資訊&quot;&gt;E. 上傳和儲存圖像檔案及版權資訊&lt;/h2&gt;

&lt;p&gt;使用 IPFS 網站提供的 go-ipfs 軟件進行仿真。如圖13 所示，此電腦已作為 IPFS 網路中的節點成功啟動。圖3 顯示了該電腦在 IPFS 網路中的 ID 和本地 HTTP 地址&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-13.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖13 啟動 go-ipfs&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;創建一個名為 lena 的資料夾，其中包含兩個文件，這兩個文件是帶有浮水印的圖像 lena_marked.jpg 和包含版權訊息和相應區塊訊息的文本文件 copyright_information.txt。如圖14 所示，此文件夾已成功上傳到 IPFS，並且獲得了唯一證書-該文件夾的哈希值。此哈希值是IPFS 網路中此資料夾的名稱。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-14.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖14 上傳資料夾 lena&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;f-瀏覽和下載圖像和版權訊息&quot;&gt;F. 瀏覽和下載圖像和版權訊息&lt;/h2&gt;

&lt;p&gt;與步驟E一樣，仍使用 go-ipfs 套件。成功上傳後，使用通用的 HTTP 瀏覽器瀏覽該文件夾。如圖15所示，在地址欄中輸入
http://localhost:8080/ipfs/QmXik2CN6GsSvxudKxoXdXGLpuAaKiuzkrLDuAg2chc8T2&lt;/p&gt;

&lt;p&gt;它成功顯示了該資料夾的內容。單擊任何文件以瀏覽內容，如圖16和17所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-15.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖15 顯示 lena 資料夾&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-16.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖16 顯示浮水印圖像 lena_marked.jpg&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-17.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖17 顯示浮水印內容 copyright_information.txt&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;接下來是下載 lena 資料夾。如圖18所示，成功下載此資料夾。下載的資料夾包含兩個文件 lena_marked.jpg 和 copyright_information.txt。 如圖19所示。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-18.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖18 下載資料夾 lena&lt;/strong&gt;&lt;/center&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-19.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖19 下載資料夾 lena&lt;/strong&gt;&lt;/center&gt;

&lt;h2 id=&quot;g-自我驗證&quot;&gt;G. 自我驗證&lt;/h2&gt;

&lt;p&gt;DHA 仍用於計算原始圖像 lena.jpg 和帶水印的 lena_marked.jpg的雜湊值。最後，漢明碼距離用於比較這兩個雜湊值。如圖20所示，結果表明漢明碼距離為 0，因此這兩個圖像是同一圖像，並且兩個雜湊值均為6e0egedaccc85a1c。 該雜湊值與數位浮水印中的雜湊值和區塊鏈中的雜湊值一致，版權證明已完成。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/panda-20.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;&lt;strong&gt;圖20 兩個雜湊值和漢明碼距離&lt;/strong&gt;&lt;/center&gt;

&lt;h1 id=&quot;第四章節---結論&quot;&gt;第四章節 - 結論&lt;/h1&gt;

&lt;p&gt;面對日益嚴重的數位版權保護問題，用於版權保護的技術也應得到增強。 在此方案中，使用數位浮水印、區塊鏈、感知雜湊功能，QR Code 和 IPFS 為快速發展的網路時代及數位版權保護作業提供了全新的選擇。在文件類型方面，本文僅提及數位圖像的版權管理。將來，它可以擴展到音頻、視頻和其他多媒體文件類型，以形成多種類型的版權管理系統。而且，本文提到的這些技術仍處於快速發展時期。相信將來，理論方面將更加完善、算法將更加成熟，可以為數位版權保護作業提供更強大的支持。&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Nicholas Paul Sheppard, Reihaneh Safavi-Naini, Philip Ogunbona, “Digital watermarks for copyright protection”, Journal of Law and Information Science, vol. 12, no. 1, pp. 110-130, 2002.&lt;/li&gt;
  &lt;li&gt;Deepa Merin Jose, R. Karuppathal, A. Vincent Antony Kumar, “Copyright Protection using Digital Watermarking”, National Conference on Advances in Computer Science and Applications with International Journal of Computer Applications (NCACSA) International Journal of Computer Applications (IJCA), 2012.&lt;/li&gt;
  &lt;li&gt;Chaw-Seng Woo, Digital Image Watermarking Methods for Copyright Protection and Authentication, March 2007.&lt;/li&gt;
  &lt;li&gt;Alexander Savelyev, “COPYRIGHT IN THE BLOCKCHAIN ERA: PROMISES AND CHALLENGES” in Basic Research Program Working Paper, National Research University Higher School of Economics (HSE), 2017.&lt;/li&gt;
  &lt;li&gt;Shigeru Fujimura, Hiroki Watanabe, Atsushi Nakadaira, Tomokazu Yamada, Akihito Akutsu, Jay-(Junichi) Kishigami, “BRIGHY: A Concept for a Decentralized Rights Management System Based on Blockchain”, IEEE 5 th International Conference on Consumer Electronics Berlin (ICCE-Berlin) , 2015.&lt;/li&gt;
  &lt;li&gt;Ruzhi Xu, Lu Zhang, Huawei Zhao, Yun Peng, “Design of Network Media’s Digital Rights Management Scheme Based on Blockchain Technology”, IEEE 13th International Symposium on Autonomous Decentralized Systems, 2017.&lt;/li&gt;
  &lt;li&gt;Christoph Zauner, Implementation and Benchmarking of Perceptual Image Hash Functions, July 2010.&lt;/li&gt;
  &lt;li&gt;Vladimir Viies, POSSIBLE APPLICATION OF PERCEPTUAL IMAGE HASHING, 2015.&lt;/li&gt;
  &lt;li&gt;Ruchita Kesarkar, RW Deshpande, “A Survey on Perceptual image hash for authentication of content”, International Research Journal of Engineering and Technology (IRJET), vol. 03, no. 01, January 2016.&lt;/li&gt;
  &lt;li&gt;Hirotsugu Kinoshita, Masafumi Satoh, Terunobu Kobayashi, “A WATERMARK SYSTEM BASED ON THE STRUCTURED INFORMATION”, European Association for Signal Processing 98, vol. 4, pp. 2273-2276, September 1998.&lt;/li&gt;
  &lt;li&gt;Hirotsugu Kinoshita, “AN IMAGE DIGITAL SIGNATURE SYSTEM WITH ZKIP FOR THE GRAPH ISOMORPHISM”, IEEE INTERNATIONAL CONFERENCE ON IMAGE PROCESSING ICIP96, vol. III, pp. 247-250, September 1996.&lt;/li&gt;
  &lt;li&gt;Peter Kieseberg, Manuel Leithner, Martin Mulazzani, Lindsay Munroe, Schrittwieser Sebastian, Mayank Sinha, Edgar Weippl, “QR Code Security”, the 8th International Conference on Advances in Mobile Computing and Multimedia, pp. 430-435, 8–10 November 2010.&lt;/li&gt;
  &lt;li&gt;Kevin Peng, Harry Sanabria, Derek Wu, Charlotte Zhu, “Security Overview of QR Codes”, Massachusetts Institute of Technology 6.857 Computer and Network Security, 2014.&lt;/li&gt;
  &lt;li&gt;Sumedha Nishane, V.M. Umale, “Digital Image Watermarking based on DWT using QR Code”, International Journal of Current Engineering and Technology, June 2015.&lt;/li&gt;
  &lt;li&gt;Yang-Wai Chow, Willy Susilo, Joseph Tonien, Wei Zong, “A QR Code Watermarking Approach based on the DWT-DCT Technique”, 22nd Australasian Conference on Information Security and Privacy, 2017.&lt;/li&gt;
  &lt;li&gt;Juan Benet, IPFS - Content Addressed Versioned P2P File System (DRAFT 3) (online), 2014, [online] Available: https://ipfs.io/ipfs/QmR7GSQM93Cx5eAg6a6yRzNde1FQv7uL6X1o4k7zrJa3LX/ipfs.draft3.pdf.&lt;/li&gt;
  &lt;li&gt;pysimplechain, [online] Available: https://github.com/EricAlcaide/pysimplechain.&lt;/li&gt;
  &lt;li&gt;hands-on-learning, [online] Available: https://github.com/liuchengxu/hands-on-learning.&lt;/li&gt;
  &lt;li&gt;blockchain, [online] Available: https://github.com/itauber/blockchain.&lt;/li&gt;
  &lt;li&gt;blockchain, [online] Available: https://github.com/dvf/blockchain.&lt;/li&gt;
  &lt;li&gt;Adrian G. Bors, Ioannis Pitas, “IMAGE WATERMARKING USING DCT DOMAIN CONSTRAINTS”, Proceedings of 3rd IEEE International Conference on Image Processing, 19–19 September 1996.&lt;/li&gt;
  &lt;li&gt;Faisal Alurki, Russell Mersereau, “A ROBUST DIGITAL WATERMARK PROCEDURE FOR STILL IMAGES USING DCT PHASE MODULATION”, 10th European Signal Processing Conference, 4–8 September 2000.&lt;/li&gt;
  &lt;li&gt;Chetna, “Digital Image Watermarking using DCT”, A Monthly Journal of Computer Science and Information Technology, vol. 3, no. 9, pp. 586-591, September 2014.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">本篇文章翻譯自 Design Scheme of Copyright Management System Based on Digital Watermarking and Blockchain 的內容，數位浮水印概念我們從圖像、影像..等，已經玩了許久當他結合區塊鏈又會產生什麼火花呢？</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/panda-21.png" /></entry><entry><title type="html">比特幣粉塵和空塊</title><link href="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E7%B2%89%E5%A1%B5%E5%92%8C%E7%A9%BA%E5%A1%8A/" rel="alternate" type="text/html" title="比特幣粉塵和空塊" /><published>2019-11-11T00:00:00+08:00</published><updated>2019-11-11T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E7%B2%89%E5%A1%B5%E5%92%8C%E7%A9%BA%E5%A1%8A</id><content type="html" xml:base="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E7%B2%89%E5%A1%B5%E5%92%8C%E7%A9%BA%E5%A1%8A/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/比特币粉尘和空块.html&quot;&gt;原文&lt;/a&gt;：比特币粉尘和空块   &lt;br /&gt;
最近看了bitcoinj的TransactionOutput類發現了裡面的關於粉塵的一些功能。網上搜索關於比特幣粉塵的知識，發現了空塊攻擊和粉塵攻擊的一些說明，但是隻是簡單地進行表述而已。也看到了礦工如何利用各種手段進行作弊，這個可能就是區塊鏈所不能監控的了。所以我覺得區塊鏈的問題還是很多的。&lt;/p&gt;

&lt;h2 id=&quot;什麼是空塊攻擊&quot;&gt;什麼是空塊攻擊&lt;/h2&gt;

&lt;p&gt;空塊的意思很明確，就是區塊中沒有交易，其實不管怎麼樣應該是有一筆交易的，就是挖礦獎勵的coinbase交易。但是呢塊被接收是經過大量的計算工作量的，所以這個看起來有點不太現實。從經濟的角度來說這是不太靠譜，但是這種攻擊最大的好處就是不用啟動算力攻擊。比如說你有全網1%的算力，那麼發起空包攻擊的概率也是很大的，但是就是這1%的算力也是不小的投入。算力攻擊其實就是能控制全網51%的算力，這個時候你可以隨意更改區塊的資訊。我在想以後會不會出現網路攻擊，癱瘓大部分網路，在一小片網路中佔據算力，從本質上說，區域網內的機器也可以進行挖礦，所以也比較困難。&lt;/p&gt;

&lt;p&gt;另外個別情況下偶爾一次，也沒有問題，但短期內頻繁空塊就是攻擊了，其效果是使交易記憶體池變大，交易平均確認時間變長。其實已經有很多礦池消滅了空塊的，技術上沒有難度的。打包空塊並不會比打包滿塊有優勢。但是有ASICBoost專利就不同了，空塊有利於ASICBoost專利的實施。&lt;/p&gt;

&lt;h2 id=&quot;粉塵攻擊&quot;&gt;粉塵攻擊&lt;/h2&gt;

&lt;p&gt;如果要想理解粉塵攻擊就必須先理解什麼是粉塵。任何會消耗其費用三分之一以上的交易輸出都不是比特幣系統現在想要處理的東西，所以我們稱之為“粉塵輸出”，並且它們是非標準的。&lt;/p&gt;

&lt;p&gt;一個典型的輸出是33位元組（pubkey hash +操作碼），需要輸入148位元組的消耗，所以我們將它們加在一起以找出用於傳輸這個數值的總資料量。請注意，這個公式對於任何不是付費地址輸出的東西都是錯誤的，不幸的是，我們必須遵循比特幣核心的錯誤以確保我們被認為是標準。一個更好的公式可以估計滿足所有不同指令碼類型所需的資料大小，或者只是使用硬編碼33。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 這個是根據實時的資料進行的計算。
public Coin getMinNonDustValue(Coin feePerKb) {
    final long size = this.unsafeBitcoinSerialize().length + 148;
    // 計算交易費
    return feePerKb.multiply(size).divide(1000);
}
// 預設是費用的3倍
public Coin getMinNonDustValue() {
    return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的這段程式碼就是用來計算最小的輸出，如果小於這個輸出值，我們就認為這個輸出是粉塵輸出。&lt;/p&gt;

&lt;h2 id=&quot;關於小金額的問題&quot;&gt;關於小金額的問題&lt;/h2&gt;

&lt;p&gt;如果地址上未花費輸出比較小，那麼很有可能就是使用的時候，這筆錢都不能支付交易費（這就是粉塵判斷所不能接受的），這樣會損失金額。也可以通過賬戶不停地將賬戶的錢轉移到大賬戶裡面去，看來不管是何種數字貨幣，都不能避免零頭損失的問題。我們做錢包的應用多少都存在這樣的問題。但是以太坊不是基於UTXO，而是基於賬戶多少能緩解不少的問題。&lt;/p&gt;

&lt;h2 id=&quot;廣播攻擊&quot;&gt;廣播攻擊&lt;/h2&gt;

&lt;p&gt;如果不停地向網路廣播大量的垃圾交易會阻塞網路，如果我們的節點能檢測出這個交易是非法的，並且停止廣播，那麼這個問題就不會很嚴重，但是如果修改了程式碼，不做這個的檢測就會出現大問題。比如說礦池大量傳送這樣的交易，這就會引起災難性的後果。&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文：比特币粉尘和空块 最近看了bitcoinj的TransactionOutput類發現了裡面的關於粉塵的一些功能。網上搜索關於比特幣粉塵的知識，發現了空塊攻擊和粉塵攻擊的一些說明，但是隻是簡單地進行表述而已。也看到了礦工如何利用各種手段進行作弊，這個可能就是區塊鏈所不能監控的了。所以我覺得區塊鏈的問題還是很多的。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/134.jpg" /></entry><entry><title type="html">比特幣地址和 script</title><link href="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80&script/" rel="alternate" type="text/html" title="比特幣地址和 script" /><published>2019-11-11T00:00:00+08:00</published><updated>2019-11-11T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80&amp;script</id><content type="html" xml:base="http://localhost:4000/news/2019/11/11/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80&amp;script/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/比特币地址和脚本.html&quot;&gt;原文&lt;/a&gt;：比特币地址和脚本  &lt;br /&gt;
這兩天由於要做多簽名的錢包的問題，所以一直在關注比特幣錢包的知識，當我看到bitcoinj裡面的知識時，發現了ScriptBuilder的類，也發現了bitcoinj文件中有提到怎麼使用多簽名的錢包，這裡就簡單帶過吧，今天的主題還是要說明錢包的地址和 script 的一些知識。&lt;/p&gt;

&lt;h2 id=&quot;地址&quot;&gt;地址&lt;/h2&gt;

&lt;p&gt;首先關於錢包地址大概有以下幾種：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;類型&lt;/th&gt;
      &lt;th&gt;版本字首（hex）&lt;/th&gt;
      &lt;th&gt;Base58結果的字首&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;傳統bitcoin地址&lt;/td&gt;
      &lt;td&gt;0x00&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;P2SH&lt;/td&gt;
      &lt;td&gt;0x05&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;比特幣測試網路地址&lt;/td&gt;
      &lt;td&gt;0x6F&lt;/td&gt;
      &lt;td&gt;m或者n&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;私鑰WIF&lt;/td&gt;
      &lt;td&gt;0x80&lt;/td&gt;
      &lt;td&gt;5、K、L&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIP-38編碼私鑰&lt;/td&gt;
      &lt;td&gt;0x0142&lt;/td&gt;
      &lt;td&gt;6P&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIP-32編碼私鑰&lt;/td&gt;
      &lt;td&gt;0x0488B21E&lt;/td&gt;
      &lt;td&gt;xpub&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其實地址的類型和交易的解鎖也是有很大的相關關係的。 &lt;strong&gt;如果你創造了一種新的地址類型，並配置了相關的鎖定和解鎖 script ，那麼這個地址是可以工作的，只是沒有錢包支援，你需要提供能夠利用這種地址類型，傳送解鎖和鎖定 script 的客戶端，這樣你的地址就可以生效了，當然你也要相容其他類型，如果傳送的地址類型是其他的，那你的輸出 script 要按照對應地址類型的要求來才行&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;比特幣地址的生成規則如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;500&quot; src=&quot;/img/132.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;傳統的比特幣地址-script-p2pkh&quot;&gt;傳統的比特幣地址 script P2PKH&lt;/h2&gt;

&lt;p&gt;對於比特幣 script 的語言介紹這裡不提太多，比特幣 script 其實就是一種基於堆棧的 script 語言，堆棧是一個非常簡單的資料結構，可以被視為一疊卡片。棧允許兩個操作：push和pop（推送和彈出）。&lt;/p&gt;

&lt;p&gt;對於解鎖 script 大概是這樣的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 OP_DUP OP_HASH160 &amp;lt;Cafe Public Key Hash&amp;gt; OP_EQUALVERIFY OP_CHECKSIG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;前面輸出的鎖定 script 是這樣的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;sig&amp;gt; &amp;lt;pubk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那麼整體的 script 是這樣的：
&lt;img src=&quot;/img/133.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;p2sh&quot;&gt;P2SH&lt;/h2&gt;

&lt;p&gt;Gavin Andresen在bip16提出一種P2SH(pay to Script Hash)方法，主要目的有兩個，一是容許傳送者構造豐富的交易類型，二是將位元組從A-&amp;gt;B的output轉移到B-&amp;gt;C的input(A-&amp;gt;B的output script中將是固定長度)。&lt;/p&gt;

&lt;p&gt;對於解鎖的 script 是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我們可以理解成解數學中的難題，hash(x) = 6fe28c0ab6f1b372c1a6 我們只是提供一個x滿足這個條件，就可以證明我可以花費這筆錢了。這裡 &lt;code class=&quot;highlighter-rouge&quot;&gt;6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000&lt;/code&gt; 不是簡單的一個數字的hash，而是一段script的hash(簡稱redeemScript),  &lt;strong&gt;我們可以理解成只要你提供了一段script，它的二進位制hash和目標匹配，那麼你就可以花費這筆錢了，注意這裡是前端 script 執行的輸出是x就行了。&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;請注意，雖然這樣的交易很有趣，但它們並不安全，因為它們不包含任何簽名，因此任何試圖花費它們的交易都可以用將資金髮送到其他地方，用不同的交易來替代&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;p2sh地址生成&quot;&gt;P2SH地址生成&lt;/h3&gt;

&lt;p&gt;可以使用 go-bitcoin-multisig 生成，Github地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go-bitcoin-multisig keys --count 3 --concise
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成結果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;KEY #1
Private key:
5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3
Public key hex:
04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd
Public Bitcoin address:
1JzVFZSN1kxGLTHG41EVvY5gHxLAX7q1Rh
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--------------
--------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;KEY #2
Private key:
5JX3qAwDEEaapvLXRfbXRMSiyRgRSW9WjgxeyJQWwBugbudCwsk
Public key hex:
046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187
Public Bitcoin address:
14JfSvgEq8A8S7qcvxeaSCxhn1u1L71vo4
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--------------
--------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;KEY #3
Private key:
5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV
Public key hex:
0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83
Public Bitcoin address:
1Kyy7pxzSKG75L9HhahRZgYoer9FePZL4R
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--------------
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著我們取出裡面所有的Public key（hex格式）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Key A:
04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd
Key B:
046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187
Key C:
0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然後就可以使用這三組Public key組合起來（A,B,C）進行多重簽名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go-bitcoin-multisig address --m 2 --n 3 --public-keys 04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd,046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187,0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著就生成了P2SH地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;---------------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;Your *P2SH ADDRESS* is:
347N1Thc213QqfYCz3PZkjoJpNv5b14kBd
Give this to sender funding multisig address with Bitcoin.
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;---------------------
---------------------
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;Your *REDEEM SCRIPT* is:
524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae
Keep private and provide this to redeem multisig balance later.
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;---------------------
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;多重簽名地址&quot;&gt;多重簽名地址&lt;/h2&gt;

&lt;p&gt;在bitcoin bips歷史上先有M-of-N Transaction(bip-11),然後才有Pay To Script Hash(bip-16)(簡稱P2SH). 按照這個順序，其實比特幣中實現多重簽名有兩種方法：&lt;/p&gt;

&lt;h3 id=&quot;原始的方法bip-11&quot;&gt;原始的方法(bip-11)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scriptPubKey : m {pubkey}...{pubkey} n OP_CHECKMULTISIG
scriptSig : OP_0 ...signatures...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以檢視一下例項：&lt;code class=&quot;highlighter-rouge&quot;&gt;09dd94f2c85262173da87a745a459007bb1eed6eeb6bfa238a0cd91a16cf7790&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;用p2sh來實現&quot;&gt;用P2SH來實現&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scriptSig: [signature] {[pubkey] OP_CHECKSIG}
scriptPubKey: OP_HASH160 [20-byte-hash of {[pubkey] OP_CHECKSIG} ] OP_EQUAL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這裡&lt;code class=&quot;highlighter-rouge&quot;&gt;{[pubkey] OP_CHECKSIG}&lt;/code&gt;就是我們提到&lt;code class=&quot;highlighter-rouge&quot;&gt;redeemScript&lt;/code&gt;程式碼. 例項：&lt;code class=&quot;highlighter-rouge&quot;&gt;3c9018e8d5615c306d72397f8f5eef44308c98fb576a88e030c25456b4f3a7ac&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;總結&quot;&gt;總結&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;首先P2SH和MultiSig是完全不同兩碼事，很多文章將P2SH表述成MultiSig，這是不恰當的。只不過現在可以用P2SH來實現MultiSig。&lt;/li&gt;
  &lt;li&gt;比特幣的關鍵是認證，剛開始中本聰提供用私鑰認證，後來人發明了用hash(redeemScript)認證.&lt;/li&gt;
  &lt;li&gt;P2SH豐富了交易類型，簡單易擴充套件&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;參考和引用&quot;&gt;參考和引用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://8btc.com/thread-23440-1-1.html&quot;&gt;http://8btc.com/thread-23440-1-1.html&lt;/a&gt;&lt;/p&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文：比特币地址和脚本 這兩天由於要做多簽名的錢包的問題，所以一直在關注比特幣錢包的知識，當我看到bitcoinj裡面的知識時，發現了ScriptBuilder的類，也發現了bitcoinj文件中有提到怎麼使用多簽名的錢包，這裡就簡單帶過吧，今天的主題還是要說明錢包的地址和 script 的一些知識。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/131.png" /></entry><entry><title type="html">隔離見證、閃電網路概述</title><link href="http://localhost:4000/news/2019/11/10/%E9%9A%94%E9%9B%A2%E8%A6%8B%E8%AD%89-%E9%96%83%E9%9B%BB%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%BF%B0/" rel="alternate" type="text/html" title="隔離見證、閃電網路概述" /><published>2019-11-10T00:00:00+08:00</published><updated>2019-11-10T00:00:00+08:00</updated><id>http://localhost:4000/news/2019/11/10/%E9%9A%94%E9%9B%A2%E8%A6%8B%E8%AD%89%E3%80%81%E9%96%83%E9%9B%BB%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%BF%B0</id><content type="html" xml:base="http://localhost:4000/news/2019/11/10/%E9%9A%94%E9%9B%A2%E8%A6%8B%E8%AD%89-%E9%96%83%E9%9B%BB%E7%B6%B2%E8%B7%AF%E6%A6%82%E8%BF%B0/">&lt;p&gt;&lt;a href=&quot;http://gavinzhang.work/blockchain/比特币/隔离见证、闪电网络理解.html&quot;&gt;原文&lt;/a&gt;：隔离见证、闪电网络理解  &lt;br /&gt;
隔離見證已經於2017年8月在比特幣上啟動了。最近比特幣正在朝著下一個擴容方案努力，閃電網路 Lightning Network。閃電網路的啟動必須基於更多的使用者使用隔離見證地址。&lt;/p&gt;

&lt;h3 id=&quot;源起&quot;&gt;源起&lt;/h3&gt;

&lt;p&gt;現在的比特幣網路交易量特別大，但是區塊10分鐘一個，一個區塊限制1M大小，這就造成了比特幣網路的擁堵。如果大家瞭解交易結構就一定知道加解密指令碼，這些指令碼都是放在區塊裡面的，於是大家就想如何能把指令碼從區塊中拿出來單獨儲存，這樣一個區塊不就可以容納更多的交易了嗎？於是下圖的結構就出現了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/125.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;隔離見證的其中一個好處是能緩解我們交易堵塞的問題。但是最重要的是為了閃電網路鋪路。一種建立在比特幣底層網路的智慧合約。&lt;/p&gt;

&lt;p&gt;隔離驗證確實不是很好的解決之道，因為指令碼還是需要儲存的，沒有指令碼的交易，那麼這個交易是不是可以隨便花費。另外對於錢包節點都是要去檢查指令碼的準確性，這個還是需要有指令碼資料的，所以這個也不是簡單的事情吧！&lt;/p&gt;

&lt;h3 id=&quot;分叉&quot;&gt;分叉&lt;/h3&gt;

&lt;p&gt;隔離見證可以應用軟分叉或者硬分叉，當然最終實施的是軟分叉。新的節點是可以相容後者的，但是舊節點是不是相容新版本的區塊這個是需要考慮的，如果不相容那麼就肯定出現軟分叉。但是官方的說明是舊版本的節點不用升級，這句話的話外之音就是舊節點也是支援新版的區塊（包含隔離見證）。看來這項技術很好。至於BCH應該是人為的硬分叉了。這部分知識可參考隔離見證比任何硬分叉都高階&lt;/p&gt;

&lt;p&gt;上篇的文章中提到了Core團隊很多的問題，也許確實有問題，但是作為開發者，考慮前後版本相容也是應該的，畢竟誰都不想出問題。另外還有一點就是一旦一個項目上線，可做的可能真的就不多了，一是改動複雜，程式設計師不想動，二是工作量比較大！對於這場戰爭我還是當個第三者吧，看慣了公司風風雨雨，拿刀開乾的人還是很少的。一旦變革失敗也不會有人同情，core團隊可能有自己的考量。畢竟對於資本市場來說一切都是那麼的浮躁。&lt;/p&gt;

&lt;h2 id=&quot;閃電網路&quot;&gt;閃電網路&lt;/h2&gt;

&lt;p&gt;閃電網路提供了一個可擴充套件的微支付通道網路。交易雙方若在區塊鏈上預先設有支付通道，就可以多次、高頻、雙向地通過軋差方式實現瞬間確認的微支付；雙方若無直接的點對點支付通道，只要網路中存在一條連通雙方的、由多個支付通道構成的支付路徑，閃電網路也可以利用這條支付路徑實現資金在雙方之間的可靠轉移。&lt;/p&gt;

&lt;p&gt;上面的這段話可能比較難於理解，總的來說就是通過多簽名實現多重交易的劃分，這裡需要了解比&lt;a href=&quot;http://gavinzhang.work/2018/03/16/blockchain/bitcoin%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0/&quot;&gt;特幣的智慧合約&lt;/a&gt;和&lt;a href=&quot;http://gavinzhang.work/2018/03/17/blockchain/bitcoin%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90/&quot;&gt;P2SH指令碼&lt;/a&gt;的相關知識。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;閃電網路並不試圖解決單次支付的銀貨對付問題，其假設是單次支付的金額足夠小，即使一方違約另一方的損失也非常小，風險可以承受。因此使用時必須注意“微支付”這個前提。多少資金算“微”，顯然應該根據業務而定。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;技術本質&quot;&gt;技術本質&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;閃電網路的關鍵技術有三，後後依賴於前前，依次是：RSMC，HTLC和閃電網路。技術實現雖然複雜，但本質卻很簡單。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RSMC解決了通道中幣單向流動問題，HTLC解決了幣跨節點傳遞的問題。這兩個類型的交易組合構成了閃電網路。這裡面還會用到我們之前提到的&lt;a href=&quot;http://gavinzhang.work/2018/03/26/blockchain/BIP-65%20OP-CHECKLOCKTIMEVERIFY/&quot;&gt;BIP-65 OP_CHECKLOCKTIMEVERIFY&lt;/a&gt;和&lt;a href=&quot;http://gavinzhang.work/2018/03/26/blockchain/BIP-68%E4%BD%BF%E7%94%A8%E5%85%B1%E8%AF%86%E5%BA%8F%E5%88%97%E5%8F%B7%E8%AE%B0%E5%BD%95%E7%9B%B8%E5%AF%B9%E9%94%81%E5%AE%9A%E6%97%B6%E9%97%B4/&quot;&gt;BIP-68使用共識序列號記錄相對鎖定時間&lt;/a&gt;，這兩篇文件提到了交易鎖定的問題，也提到了分叉的問題。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;rsmc&quot;&gt;RSMC&lt;/h3&gt;

&lt;p&gt;我們先來建立一個序列到期可撤銷合約（RSMC），Alice和Bob是合作方，經常有比特幣往來，所以他們決定各拿出0.5BTC放入 &lt;strong&gt;通道&lt;/strong&gt; 中，便於業務往來。解釋一下下方RSMC交易的結構（圖X），左側為Alice的視角，右側為Bob的視角。中間Funding Tx為共同可見，C1a和RD1a為Alice持有，C1b和RD1b為Bob持有。交易圖中帶有尖括號的簽名表示待填入。&lt;/p&gt;

&lt;h4 id=&quot;建立交易&quot;&gt;建立交易&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/126.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;來對上面的圖進行一番解釋：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;雙方各拿出0.5BTC，構建Funding Tx，輸出為Alice和Bob的2/2多重簽名。此時，Funding Tx未簽名，更不廣播。&lt;/li&gt;
  &lt;li&gt;Alice構造Commitment Tx：C1a和RD1a，並交給Bob簽名。C1a的第一個輸出為多重簽名地址，Alice的另一把私鑰Alice2和Bob的2/2多重簽名，第二個輸出為Bob 0.5BTC。&lt;/li&gt;
  &lt;li&gt;RD1a為C1a第一個輸出的花費交易，輸出給Alice0.5BTC，但此類型交易帶有sequence，作用是阻止當前交易進塊，只有前向交易有sequence個確認時才能進塊。&lt;/li&gt;
  &lt;li&gt;Bob構造Commitment Tx：C1b和RD1b，並交給Alice簽名。結構與C1a、RD1a是對稱關係。&lt;/li&gt;
  &lt;li&gt;Bob對C1a和RD1a進行簽名，並將簽名給Alice；同理，Alice對C1b和RD1b簽名，完成後給Bob。此時，由於並未對Funding Tx進行簽名，任何一方均無法作惡，任何一方也不會有任何損失。&lt;/li&gt;
  &lt;li&gt;雙方均完成對commitment Tx的簽名並交換後，各自再對Funding Tx進行簽名，並交換。此時，Funding Tx是完整的交易，廣播之。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述過程以及結構圖的描述，就是建立RSMC的全部過程。C1a, C1b兩筆交易花費的是同一個輸出，故他們兩個交易只有一個能進塊。若Alice廣播C1a，則Bob立即拿到0.5BTC（C1a的第二個輸出），而Alice需要等C1a得到1000個確認，才能通過RD1a的輸出拿到0.5BTC。另一方，若Bob廣播C1b，則Alice立即拿到0.5BTC，Bob等待C1b得到1000個確認，才能通過RD1b拿到0.5BTC。也就是說，單方廣播交易終止合約的那一方會延遲拿到幣，而另一放則立即拿幣。&lt;/p&gt;

&lt;h4 id=&quot;交易更新&quot;&gt;交易更新&lt;/h4&gt;

&lt;p&gt;Alice和Bob各自0.5BTC的餘額，此時Alice從Bob處購買了一件商品，價格為0.1BTC，那麼餘額應該變為Alice 0.4BTC，Bob 0.6BTC。於是建立新的Commitment Tx，對於Alice來說是C2a 和RD2a，對於Bob來說是C2b和RD2b，過程與上面類似。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/127.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此時兩個狀態均是有效的，那麼最核心的問題來了，如何才能徹底廢棄掉C1a和C1b呢？
RSMC採用了一個非常巧妙的方法，在C1a的第一個輸出中，採用了Alice2和Bob的多重簽名，Alice將Alice2的私鑰交給Bob，即表示Alice放棄C1a，承認C2a。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/128.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Alice交出Alice2的私鑰給Bob，那麼Bob就可以修改RD1a的輸出給他自己，形成新的交易BR1a。若Alice破壞合約存在C2a的情況下依然廣播出C1a，那麼Alice的懲罰就是失去她全部的幣。Alice交出Alice2的私鑰，或者對交易BR1a進行簽名，兩者是等同的，都是對C1a的放棄。反之亦然，Bob交出Bob2的私鑰給Alice即意味放棄C1b，而僅能認可C2b。引入sequence的目的是，阻止後續交易進塊（RD1a），給出一個實施懲罰視窗期，當發現對方破壞合約時，可以有1000個塊確認的時間去實施懲罰交易，即廣播BR1a代替RD1a。若錯過1000個塊時間視窗，則無法再實施懲罰了（RD1a進塊了）。&lt;/p&gt;

&lt;h4 id=&quot;交易關閉&quot;&gt;交易關閉&lt;/h4&gt;

&lt;p&gt;關閉RSMC，直接按照最終的餘額構造出一個Commitment TX即可，例如輸出為Alice0.1BTC，Bob0.9BTC，無需再設定多重簽名，構造懲罰交易等。&lt;/p&gt;

&lt;h4 id=&quot;中轉交易真實的閃電網路htlc&quot;&gt;中轉交易（真實的閃電網路，HTLC）&lt;/h4&gt;

&lt;p&gt;我們來看一下基本的流程圖吧！
&lt;img src=&quot;/img/129.png&quot; alt=&quot;&quot; /&gt;
這裡面的R就是支付的口令，其實就是交易節點之間沒有直連的通道，需要其他人待轉，這些人會收手續費。這裡面需要解決幾個問題（我的思考）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何建立初始的支付通道&lt;/li&gt;
  &lt;li&gt;如果兩個節點間無直接支付通道，如何找到最佳的支付通道。&lt;/li&gt;
  &lt;li&gt;如何保證第三方不作弊，防止現金丟失（前面的講的都是這個問題）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;總結&quot;&gt;總結&lt;/h3&gt;

&lt;h4 id=&quot;rsmc-1&quot;&gt;RSMC&lt;/h4&gt;

&lt;p&gt;閃電網路的基礎是交易雙方之間的雙向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定義了該雙向微支付通道的最基本工作方式。這是要求雙方都拿出資金放到合約上，然後輸出動態分配，最後確認輸出後上鏈，這樣的好處就是支付完全是在鏈下執行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;為了鼓勵雙方儘可能久地利用通道進行交易，RSMC對主動終止通道方給予了一定的懲罰：主動提出方其資金到賬將比對方晚，因此誰發起誰吃虧。這個設計雖然增加了技術複雜度，但應該說是合理的。&lt;/strong&gt;  這樣許多交易就會在區塊鏈下面執行，不會產生交易（只產生預備交易），最後交易才會上鍊。還有就是交易的憑證怎麼保證？所以這個方式或許也有很多技術和現實的缺陷所在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通道餘額分配方案的本質是結算準備金。在此安排下，因為要完全控制資金交收風險，每筆交易都不能突破當前結算準備金所施限制。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;htlc&quot;&gt;HTLC&lt;/h4&gt;

&lt;p&gt;RSMC只支援最簡單的無條件資金支付，HTLC（Hashed Timelock Contract）進一步實現了有條件的資金支付，通道餘額的分配方式也因此變得更為複雜。&lt;/p&gt;

&lt;p&gt;通過HTLC，Alice和Bob可以達成這樣一個協議：協議將鎖定Alice的0.1 BTC，在時刻T到來之前（T以未來的某個區塊鏈高度表述），如果Bob能夠向Alice出示一個適當的R（稱為祕密），使得R的雜湊值等於事先約定的值H(R)，Bob就能獲得這0.1 BTC；如果直到時刻T過去Bob仍然未能提供一個正確的R，這0.1 BTC將自動解凍並歸還Alice。&lt;/p&gt;

&lt;h2 id=&quot;雷電網路&quot;&gt;雷電網路&lt;/h2&gt;

&lt;p&gt;基於閃電網路的思路，以太坊社群也提出了自己的鏈下微支付通道解決方案：雷電網路（Raiden Network）。
延續了以太坊的風格，把本來較簡單的問題複雜智慧化。大致與閃電網路相同，但細節有些地方更復雜。例如：第一層面的那個舊版本作廢，其實只要加上時間戳看哪個時間新就可以了。但是其額外增加了一個單增的Sequence Number欄位來標明哪個有效。還有記錄分配餘額即可，但雷電網路記錄的是增減變動量。在第二個層面上，雷電網路引入了較HTLC更通用和複雜的“Smart Condition”。就是說HTLC中採用的成熟簡單地求HASH函數，在雷電網路中替代成了使用者可自己設定的任意函數，就是說向外擴充套件了，更加智慧，但同時面臨的風險可能就越大。&lt;/p&gt;

&lt;h2 id=&quot;corda&quot;&gt;Corda&lt;/h2&gt;

&lt;p&gt;相近技術的低層思想是相通的，受到閃電網路思想的啟發，知名的R3也宣佈釋出非區塊鏈的分散式賬本應用Corda，其本質思想應該是與閃電網路較相近似。
關於Corda的資料較少，如整個R3較閉源封閉一樣，只是R3 CEV的首席技術官Richard Brown之前在部落格中披露些Corda的主要特點：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;沒有多餘的全局資料共享：有合法需求的參與方才可按照協議獲取資料；&lt;/li&gt;
  &lt;li&gt;Corda編寫和配置在企業間流轉，無中心控制者；&lt;/li&gt;
  &lt;li&gt;Corda在企業間單個交易水平達成共識，而不是在系統水平上；&lt;/li&gt;
  &lt;li&gt;系統設計直接支援監管觀察員節點；&lt;/li&gt;
  &lt;li&gt;交易直接由交易雙方驗證，而不是由一大群不相干的驗證者進行；&lt;/li&gt;
  &lt;li&gt;支援多種共識機制；&lt;/li&gt;
  &lt;li&gt;記錄了智慧合約程式碼和人類語言法律檔案的清晰聯絡；&lt;/li&gt;
  &lt;li&gt;用行業標準工具建立；&lt;/li&gt;
  &lt;li&gt;沒有原始加密貨幣。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;總結-1&quot;&gt;總結&lt;/h2&gt;

&lt;p&gt;將交易和智慧合約的執行放在鏈下快速地執行，僅在必要時才將其在鏈上公開結算執行，這就是閃電網路帶給我們的絕佳思路。同時可增加對閃電結鏈上算時的手續費，減輕鏈上壓力的同時有可能提升礦工收入，因理論上不可能所有交易都閃電。比特幣主鏈上交易有其它任何形式鏈下交易或側鏈交易所無法替代的優點。&lt;/p&gt;

&lt;h2 id=&quot;參考和引用&quot;&gt;參考和引用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32613487&quot;&gt;三分鐘讓你瞭解什麼是Segwit隔離見證&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chainnode.com/post/45833&quot;&gt;隔離見證比任何硬分叉都高階&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.8btc.com/article/95385&quot;&gt;比特幣擴容為什麼選擇2MB？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/46515457&quot;&gt;什麼是比特幣的閃電網路？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/58567061&quot;&gt;什麼是隔離見證？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.8btc.com/article/92887&quot;&gt;詳解最近大熱的閃電網路、雷電網路和CORDA&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/lM0p3ikVBdw1zE50IWtMZA&quot;&gt;6.9Bite醬一閃電網路⚡大白話零門檻講解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Cypherpunks Core</name></author><summary type="html">原文：隔离见证、闪电网络理解 隔離見證已經於2017年8月在比特幣上啟動了。最近比特幣正在朝著下一個擴容方案努力，閃電網路 Lightning Network。閃電網路的啟動必須基於更多的使用者使用隔離見證地址。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/125.png" /></entry></feed>